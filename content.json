{"meta":{"title":"W。的个人博客","subtitle":"只想做一只安静的程序猿","description":"","author":"W。","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-11-11T00:53:54.000Z","updated":"2019-11-11T00:54:12.947Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-11-11T00:54:23.000Z","updated":"2019-11-11T00:54:38.647Z","comments":true,"path":"link/index.html","permalink":"http://yoursite.com/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-11T00:53:14.000Z","updated":"2019-11-11T00:53:41.229Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"算法之线性结构","slug":"算法之线性结构","date":"2019-11-15T11:10:28.000Z","updated":"2019-11-25T06:47:01.932Z","comments":true,"path":"2019/11/15/算法之线性结构/","link":"","permalink":"http://yoursite.com/2019/11/15/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/","excerpt":"","text":"线性结构 线性结构是数据结构中的一种分类，用于表示一系列的元素形成的有序集合。 常见的线性结构包括：数组、链表、栈、队列 数组 特别注意：这里所说的数组是数据结构中的数组，和JS中的数组不一样。js原本的数组底层是用链表来实现的，在经过v8引擎后，v8引擎上的js的数组也等于数据结构中的数组 数组是一整块连续的内存空间，它由固定数量的元素组成，数组具有以下基本特征： 整个数组占用的内存空间是连续的 数组中元素的数量是固定的（不可增加也不可减少），创建数组时就必须指定其长度 每个元素占用的内存大小是完全一样的 根据数组的基本特征，我们可以推导出数组具有以下特点： 通过下标寻找对应的元素效率极高，因此遍历速度快（只需要通过运算就可以得到下一个元素） 无法添加和删除数据，虽然可以通过某种算法完成类似操作，但会增加额外的内存开销或时间开销 如果数组需要的空间很大，可能一时无法找到足够大的连续内存 链表为弥补数组的缺陷而出现的一种数据结构，它具有以下基本特征： 每个元素除了存储数据，需要有额外的内存存储一个引用（地址），来指向下一个元素 每个元素占用的内存空间并不要求是连续的 往往使用链表的第一个节点（根节点）来代表整个链表 根据链表的基本特征，我们可以推导出它具有以下特点： 长度是可变的，随时可以增加和删除元素 插入和删除元素的效率极高 由于要存储下一个元素的地址，会增加额外的内存开销 通过下标查询链表中的某个节点，效率很低，因此链表的下标遍历效率低（下标获取元素，都是需要从头开始获取: a[3] -&gt; a[0] a[1] a[2] -&gt; a[3]） 手动用代码实现链表手写一个链表结构，并完成一些链表的相关函数。 1234567891011121314151617/** * 构造函数：能构造出节点(每个节点可以代表一个链表) * @param &#123;*&#125; value */function Node(value) &#123; this.value = value this.next = null //内存地址，用于指向下一个节点&#125;const a = new Node('a')const b = new Node('b')const c = new Node('c')a.next = bb.next = c //构建出一个简单的链表，a节点是根节点，可以表示整个链表// console.log(a) 遍历打印12345678910111213141516171819/** * 遍历打印出整个链表 * @param &#123;*&#125; root 一个节点 *///分治法，把一个整体分成一个小部分加另一个整体，先完成小部分的运算。function print(root) &#123; if(!root) return console.log(root.value) print(root.next)&#125;//穷举法，把所有的都遍历一遍function print (root) &#123; while(root) &#123; console.log(root.value) root = root.next &#125;&#125;// print(a) 获取链表的长度1234567891011/** * 获取链表的长度 * @param &#123;*&#125; root */function count(root) &#123; if(!root) return 0 return count(root.next) + 1&#125;// const result = count(a)// console.log(result) 通过下标获取链表中的某个数据12345678910111213141516171819/** * 通过下标获取链表中的某个数据 * @param &#123;*&#125; root * @param &#123;*&#125; index */function getNode(root, index) &#123; //当需要一个这个函数作用域的通用变量时，写一个辅助函数 //i ：当i等于要找的下标的时候，它的值就是要找的值 function _getNode(node, i) &#123; if (!node) return if (i === index) return node return _getNode(node.next, i + 1) &#125; //i从0开始 return _getNode(root, 0)&#125;// const result = getNode(a, 2)// console.log(result) 通过下标设置链表中的某个数据1234567891011121314151617181920/** * 通过下标设置链表中的某个数据 * @param &#123;*&#125; root * @param &#123;*&#125; index * @param &#123;*&#125; newValue */function setValue(root, index, newValue) &#123; function _setValue(node, i) &#123; if (!node) return if (i === index) &#123; node.value = newValue &#125; else &#123; return _setValue(node.next, i + 1) &#125; &#125; return _setValue(root, 0)&#125;setValue(a, 2, 'k')print(a) 在链表某一个节点之后加入一个新节点123456789101112131415/** * 在链表某一个节点之后加入一个新节点 * @param &#123;*&#125; root * @param &#123;*&#125; newValue */function insertAfter(root, newValue) &#123; if(!root) return //新构建一个节点 const newNode = new Node(newValue) newNode.next = root.next root.next = newNode&#125;// insertAfter(c, 'a')// print(a) 在链表末尾加入一个新节点123456789101112131415161718/** * 在链表末尾加入一个新节点 */function pushNode(root, newValue) &#123; if (!root) return //判断是不是最后一个节点 if (!root.next) &#123; const newNode = new Node(newValue) root.next = newNode &#125; else &#123; pushNode(root.next, newValue) &#125;&#125;// pushNode(a, 'll')// pushNode(a, 'llaa')// print(a) 删除一个链表节点12345678910111213141516/** * 删除一个链表节点 */function removeNode (root, value) &#123; //如果节点没有下一个，也返回 if(!root || !root.next) return if(root.next.value === value) &#123; root.next = root.next.next &#125; else &#123; removeNode(root.next, value) &#125;&#125;// removeNode(b, 'c')// print(a) 链表倒序1234567891011121314151617181920212223242526/** * 链表倒序 */function reverse(root) &#123; if (!root || !root.next) return //考虑两个节点的情况 //a.next = b -&gt; b.next = null //要更改为a.next = null b.next = a 同时把b当作根节点返回出去 if (!root.next.next) &#123; //保持b let temp = root.next root.next.next = root root.next = null return temp //返回b节点 &#125; else &#123; //2个节点以上的情况 let temp = reverse(root.next) //temp为后续节点的返回 root.next.next = root root.next = null return temp &#125;&#125;const result = reverse(a)print(result","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构和算法概述","slug":"算法","date":"2019-11-14T10:02:06.000Z","updated":"2019-11-25T03:10:47.927Z","comments":true,"path":"2019/11/14/算法/","link":"","permalink":"http://yoursite.com/2019/11/14/%E7%AE%97%E6%B3%95/","excerpt":"","text":"数据结构和算法概述 什么是数据结构？ 存储和运算是程序的两大基础功能，数据结构是专门研究数据存储的学科。 很多时候，我们无法仅使用简单的数字、字符串、布尔就能完整的描述数据，可能我们希望使用数组、对象、或它们组合而成的复合结构来对数据进行描述。这种复合的结构就是数据结构。 而在实际开发中，我们会发现很多场景中使用的数据结构有着相似的特征，于是，数据结构这门学科，就把这些相似的结构单独提取出来进行研究。 在这门学科中，常见的数据结构有：数组、链表、树、图等 什么是算法？ 存储和运算是程序的两大基础功能，算法是专门研究运算过程的学科。 一个程序，很多时候都需要根据一种已知数据，通过计算，得到另一个未知数据，这个运算过程使用的方法，就是算法。 而在很多的场景中，它们使用的算法有一些共通的特点，于是把这些共通的算法抽象出来，就行了常见算法。 从一个更高的角度来对算法划分，常见的算法有：穷举法、分治法、贪心算法、动态规划 数据结构和算法有什么关系？ 一个面向的是存储，一个面向的是运算，它们共同构成了计算机程序的两个重要部分。 有了相应的数据结构，免不了对这种数据结构的各种变化进行运算，所以，很多时候，某种数据结构都会自然而然的搭配不少算法。 数据结构和算法课程使用什么计算机语言？ 数据结构和算法属于计算机基础课程，它们和具体的语言无关，用任何语言都可以实现。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"ES6 之 Symbol","slug":"ES6-之-Symbol","date":"2019-11-12T03:46:17.000Z","updated":"2019-11-15T06:41:06.089Z","comments":true,"path":"2019/11/12/ES6-之-Symbol/","link":"","permalink":"http://yoursite.com/2019/11/12/ES6-%E4%B9%8B-Symbol/","excerpt":"","text":"普通符号符号是ES6新增的一个数据类型，它通过使用函数 Symbol(符号描述) 来创建 符号设计的初衷，是为了给对象设置私有属性 私有属性：只能在对象内部使用，外面无法使用 符号的特点 没有字面量（数字字面量：12312） 使用 typeof 得到的类型是字符串symbol 每次调用 Symbol 函数得到的符号永远不相等，无论符号描述是否相同123var a = Symbol('abc')var b = Symbol('abc')a === b //false 符号可以作为对象的属性名存在，这种属性称之为符号属性 开发者可以通过精心的设计，让这些属性无法通过常规方式被外界访问 —-私有变量123456789101112131415161718192021const Hexo = (() =&gt; &#123; const getRandom = Symbol('getRandom') return class Hexo &#123; constructor(attack, defence, hp) &#123; this.attack = attack this.defence = defence this.hp = hp &#125; gongji() &#123; let dmg = this.attack * this[getRandom](4,1) console.log(111,dmg) &#125; //定义了一个内部的实现方法不希望被外部访问的时候。 [getRandom](max, min) &#123; return Math.random()*(max - min) + min &#125; &#125;&#125;)()const hexo = new Hexo(10, 20, 200)hexo.gongji()hexo.getRandom() //访问不到 符号属性是不能枚举的，因此在 for-in 循环中无法读取到符号属性，Object.keys 方法也无法读取到符号属性 Object.getOwnPropertyNames 尽管可以得到所有无法枚举的属性，但是仍然无法读取到符号属性 ES6 新增 Object.getOwnPropertySymbols 方法，可以读取符号,放入一个数组里面123456789//如果写了symbol又想访问的，也是可以的const sy1 = Symbol()const obj = &#123; a: 1, b: 2, [sy1]: 3&#125;const sy = Object.getOwnPropertySymbols(obj) //拿到obj里面含有所有符号的数组obj[sy[0]] //3 符号无法被隐式转换，因此不能被用于数学运算、字符串拼接或其他隐式转换的场景，但符号可以显式的转换为字符串，通过 String 构造函数进行转换即可，console.log 之所以可以输出符号，是它在内部进行了显式转换 12345const a = Symbol('a')String(a) // 字符串Symbol(a)console.loh(a) //字符串Symbol(a)a + '' //Cannot convert a Symbol value to a string+ a //Cannot convert a Symbol value to a number 共享符号根据某个符号名称（符号描述）能够得到同一个符号 1Symbol.for(\"符号名/符号描述\") //获取共享符号 12345678910const syb1 = Symbol.for(\"abc\");const syb2 = Symbol.for(\"abc\");console.log(syb1 === syb2) //true//符号可以被访问const obj = &#123; a: 1, b: 2, [Symbol.for(\"c\")]: 3&#125;console.log(obj[Symbol.for(\"c\")]); 实现原理12345678910111213141516const Symbolfor = (() =&gt; &#123; //定义一个全局变量 const global = &#123;&#125; return function (name) &#123; //如果变量名没有值，则赋值 if(!global[name]) &#123; global[name] = Symbol(name) &#125; //有则返回对应属性名的属性值 return global[name] &#125;&#125;)()var a = Symbolfor('abc')var b = Symbolfor('abc')console.log(a === b) //true","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"ES6 之 async/await","slug":"ES6-之-async-await","date":"2019-11-10T02:27:31.000Z","updated":"2019-11-15T03:40:01.684Z","comments":true,"path":"2019/11/10/ES6-之-async-await/","link":"","permalink":"http://yoursite.com/2019/11/10/ES6-%E4%B9%8B-async-await/","excerpt":"","text":"async 和 awaitasync 和 await 是 ES2016 新增两个关键字，它们借鉴了 ES2015 中生成器在实际开发中的应用，目的是简化 Promise api 的使用，并非是替代 Promise。 async目的是简化在函数的返回值中对Promise的创建 async 用于修饰函数（无论是函数字面量还是函数表达式），放置在函数最开始的位置，被修饰函数的返回结果一定是 Promise 对象。 1234567891011121314async function test()&#123; console.log(1); return 2;&#125;//等效于// return 等效于 resolvefunction test()&#123; return new Promise((resolve, reject)=&gt;&#123; console.log(1); resolve(2); &#125;)&#125; awaitawait关键字必须出现在async函数中！！！！ await用在某个表达式之前，如果表达式是一个Promise，则得到的是thenable中的状态数据。 123456789101112131415161718192021222324252627282930313233async function test1()&#123; console.log(1); return 2;&#125;async function test2()&#123; const result = await test1(); console.log(result);&#125;test2();//等效于//await后面的语句全部是放在then里面function test1()&#123; return new Promise((resolve, reject)=&gt;&#123; console.log(1); resolve(2); &#125;)&#125;function test2()&#123; return new Promise((resolve, reject)=&gt;&#123; test1().then(data =&gt; &#123; const result = data; console.log(result); &#125;) &#125;)&#125;test2(); 如果await的表达式不是Promise，则会将其使用Promise.resolve包装后按照规则运行 12345678910111213async function test() &#123; const result = await 1; console.log(result)&#125;test();//等效于function test() &#123; return Promise.resolve(1).then(res =&gt; &#123; const result = res console.log(result) &#125;)&#125;test() 当有错误状态时12345678910111213141516async function getPromise() &#123; if (Math.random() &lt; 0.5) &#123; return 1; &#125; else &#123; throw 2; &#125;&#125;async function test() &#123; try &#123; const result = await getPromise(); console.log(\"正常状态\", result) &#125; catch (err) &#123; console.log(\"错误状态\", err); &#125;&#125; 优化之前的练习1234567891011121314151617181920212223242526272829303132333435//获取李华所在班级的老师的信息//1. 获取李华的班级id Promise//2. 根据班级id获取李华所在班级的老师id Promise//3. 根据老师的id查询老师信息 Promiseasync function findTeacher() &#123; const stus = await ajax(&#123; url: \"./data/students.json\" &#125;) let cid; for (let i = 0; i &lt; stus.length; i++) &#123; if(stus[i].name === '李华') &#123; cid = stus[i].classId &#125; &#125; const clas = await ajax(&#123; url: \"./data/classes.json\" &#125;) let tid; for (let i = 0; i &lt; clas.length; i++) &#123; if(clas[i].id === cid) &#123; tid = clas[i].teacherId &#125; &#125; const teachers = await ajax(&#123; url: \"./data/teachers.json\" &#125;) let teacher; for (let i = 0; i &lt; teachers.length; i++) &#123; if(teachers[i].id === tid) &#123; console.log(teachers[i]) &#125; &#125;&#125;findTeacher()","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"ES6 之 手写Promise","slug":"ES6-手写Promise","date":"2019-11-08T03:20:09.000Z","updated":"2019-11-15T02:22:03.168Z","comments":true,"path":"2019/11/08/ES6-手写Promise/","link":"","permalink":"http://yoursite.com/2019/11/08/ES6-%E6%89%8B%E5%86%99Promise/","excerpt":"","text":"未决阶段推向已决阶段Promise是一个构造函数，接收一个函数，函数有两个参数（resolve,reject），也是两个函数。resolve 和 reject 作用就是调用的时候是把未决阶段推向已决，也就是改变promise的状态，并且附上返回值。 12345const pro = new MyPromise((resolve, reject) =&gt; &#123; console.log('执行未决阶段的代码') resolve(1)&#125;)console.log(pro) 12345678910111213141516171819202122232425262728293031323334353637383940//写成立即执行函数，设置私有变量。const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', //设置为symbol，不让外界调用 PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus') //当前状态 return class MyPromise &#123; constructor(executor) &#123; //executor为传入的函数 //初始化数据 this[PromiseValue] = undefined this[PromiseStatus] = PENDING //resolve调用就两个作用：改变状态，设置返回值 const resolve = data =&gt; &#123; //写成箭头函数，避免this的问题 //如果当前的状态不是pending，就直接return。（promise只要状态是已决，就不能再改变） if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseValue] = data //设置数据 this[PromiseStatus] = RESOLVED //改变状态 &#125; //reject跟resolve一样 const reject = reason =&gt; &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseValue] = reason this[PromiseStatus] = REJECTED &#125; //executor在初始化的时候调用了一次 executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; &#125;&#125;)() 1234567891011121314151617181920212223242526272829303132333435363738//上面的代码有重复的部分，我们先优化一下 ---优化后const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus') //改变状态 return class MyPromise &#123; //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue &#125; constructor(executor) &#123; //executor为传入的函数 //初始化数据 this[PromiseValue] = undefined this[PromiseStatus] = PENDING //抽取了跟reject的公共代码。 const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason) &#125; //executor在初始化的时候调用了一次 executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; &#125;&#125;)() 解决throw问题除了reject函数可以把未决阶段推向rejected状态，throw也可以。 12345const pro = new MyPromise((resolve, reject) =&gt; &#123; console.log('执行未决阶段的代码') throw new Error('推向rejected状态')&#125;)console.log(pro) 12345678910111213141516171819202122232425262728293031323334353637383940const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus') //改变状态 return class MyPromise &#123; [changeStatus](newStatus, newValue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue &#125; constructor(executor) &#123; //executor为传入的函数 //初始化数据 this[PromiseValue] = undefined this[PromiseStatus] = PENDING //抽取了跟reject的公共代码。 const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason) &#125; //executor在初始化的时候调用了一次 //如果传入的是一个throw 'xxx' try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; &#125;&#125;)() 处理then和catch考虑两个问题： 什么时候往事件队列里面加处理函数？如果当前状态已经到达已决，执行处理函数，否则，把处理函数加入消息队列。 什么时候执行事件队列里面的处理函数？当状态改变的时候。 解决第一个问题：什么时候往事件队列里面加处理函数？ 123456789const pro = new MyPromise((resolve, reject) =&gt; &#123; console.log('执行未决阶段的代码') resolve(23)&#125;)//同步，当前状态到达已决pro.then(res =&gt; &#123; console.log(res)&#125;)console.log(pro) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus'), //改变状态 //新增 thenables = Symbol('thenables'), //resolve的消息队列 catchables = Symbol('catchables') //rejecte的消息队列 return class MyPromise &#123; //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue &#125; constructor(executor) &#123; //executor为传入的函数 this[PromiseValue] = undefined this[PromiseStatus] = PENDING //新增 //初始化队列 this[thenables] = [] this[catchables] = [] const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason) &#125; try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; //then函数，接收两个处理函数(resolved和rejected两个状态的) then(thenable, catchable) &#123; //如果当前状态是resolved,表示已经到达已决状态，用setTimeout模拟进入微队列。因为微队列是底层实现的，所以虽然setTimeout是宏队列，也只能用这个模拟。 if(this[PromiseStatus] === RESOLVED) &#123; setTimeout(() =&gt; &#123; thenable(this[PromiseValue]) &#125;, 0) &#125;else &#123; //否则把处理函数加入resolve的消息队列 this[thenables].push(thenable) &#125; //rejected状态则调用catch this.catch(catchable) &#125; //同上 catch(catchable) &#123; if(this[PromiseStatus] === REJECTED) &#123; setTimeout(() =&gt; &#123; catchable(this[PromiseValue]) &#125;, 0) &#125;else &#123; this[catchables].push(catchable) &#125; &#125; &#125;&#125;)() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//优化代码const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus'), //改变状态 thenables = Symbol('thenables'), //resolve的消息队列 catchables = Symbol('catchables'), //rejecte的消息队列 //新增 settleHandler = Symbol('settleHandler') //后续处理通用函数 return class MyPromise &#123; //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue &#125; constructor(executor) &#123; //executor为传入的函数 this[PromiseValue] = undefined this[PromiseStatus] = PENDING //初始化队列 this[thenables] = [] this[catchables] = [] const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason) &#125; try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; //新增 //后续处理通用函数 //handler: 要调用的处理函数 //immediatelyStatus： 需要立即执行的状态 //queue: 要加入的队列 [settleHandler](handler, immediatelyStatus, queue) &#123; if(this[PromiseStatus] === immediatelyStatus) &#123; setTimeout(() =&gt; &#123; handler(this[PromiseValue]) &#125;, 0) &#125;else &#123; //否则把处理函数加入resolve的消息队列 queue.push(handler) &#125; &#125; then(thenable, catchable) &#123; //提取出了公共函数 this[settleHandler](thenable, RESOLVED, this[thenables]) this.catch(catchable) &#125; catch(catchable) &#123; this[settleHandler](catchable, REJECTED, this[catchables]) &#125; &#125;&#125;)() 解决第二个问题：什么时候执行事件队列里面的处理函数？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus'), //改变状态 thenables = Symbol('thenables'), //resolve的消息队列 catchables = Symbol('catchables'), //rejecte的消息队列 settleHandler = Symbol('settleHandler') //后续处理通用函数 return class MyPromise &#123; //新增 加一个队列参数，当状态改变的时候，执行队列中的处理函数 //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue, queue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue queue.forEach(handler =&gt; handler(newValue)) &#125; constructor(executor) &#123; //executor为传入的函数 this[PromiseValue] = undefined this[PromiseStatus] = PENDING //初始化队列 this[thenables] = [] this[catchables] = [] //新增参数，resolve的消息队列 const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data, this[thenables]) &#125; //新增参数，reject的消息队列 const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason, this[catchables]) &#125; try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; //后续处理通用函数 //handler: 要调用的处理函数 //immediatelyStatus： 需要立即执行的状态 //queue: 要加入的队列 [settleHandler](handler, immediatelyStatus, queue) &#123; //新增：如果传入的处理函数不是function类型的，则直接返回 if(typeof handler !== 'function') &#123; return &#125; if(this[PromiseStatus] === immediatelyStatus) &#123; setTimeout(() =&gt; &#123; handler(this[PromiseValue]) &#125;, 0) &#125;else &#123; //否则把处理函数加入resolve的消息队列 queue.push(handler) &#125; &#125; then(thenable, catchable) &#123; this[settleHandler](thenable, RESOLVED, this[thenables]) this.catch(catchable) &#125; catch(catchable) &#123; this[settleHandler](catchable, REJECTED, this[catchables]) &#125; &#125;&#125;)() 链式调用（串联）12345678910111213141516const pro = new MyPromise((resolve, reject) =&gt; &#123; console.log('执行未决阶段的代码') resolve(123) &#125;) pro.then(res =&gt; &#123; console.log(1, res) return 456 &#125;).then(res =&gt; &#123; return new MyPromise((resolve, reject) =&gt; &#123; console.log(2,res) resolve(666) &#125;) &#125;).then(res =&gt; &#123; console.log(3,res) &#125;) //1 123 2 456 3 666 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus'), //改变状态 thenables = Symbol('thenables'), //resolve的消息队列 catchables = Symbol('catchables'), //rejecte的消息队列 settleHandler = Symbol('settleHandler'), //后续处理通用函数 //新增 linkPromise = Symbol('linkPromise') //串联时候创建一个新的Promise return class MyPromise &#123; //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue, queue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue queue.forEach(handler =&gt; handler(newValue)) &#125; constructor(executor) &#123; //executor为传入的函数 this[PromiseValue] = undefined this[PromiseStatus] = PENDING this[thenables] = [] this[catchables] = [] const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data, this[thenables]) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason, this[catchables]) &#125; try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; //后续处理通用函数 //handler: 要调用的处理函数 //immediatelyStatus： 需要立即执行的状态 //queue: 要加入的队列 [settleHandler](handler, immediatelyStatus, queue) &#123; if(typeof handler !== 'function') &#123; return &#125; if(this[PromiseStatus] === immediatelyStatus) &#123; setTimeout(() =&gt; &#123; handler(this[PromiseValue]) &#125;, 0) &#125;else &#123; //否则把处理函数加入resolve的消息队列 queue.push(handler) &#125; &#125; //当then返回一个promise时 //返回的promise的状态和状态数据都是由之前的promise决定的，所以要从之前的处理函数中得到状态数据,所以then中的处理函数要放到这个函数中执行 [linkPromise](thenable, catchable) &#123; return new MyPromise((resolve, reject) =&gt; &#123; // this[settleHandler](thenable, RESOLVED, this[thenables]) //返回的状态数据由thenable的返回值决定，所以要拿到thenable的返回值 this[settleHandler](data =&gt; &#123; //相当于把thenable展开 try&#123; const result = thenable(data) //当前promise的返回值 resolve(result) &#125; catch(err) &#123; //执行过程中出现问题，标记为reject reject(err) &#125; &#125;, RESOLVED, this[thenables]) this[settleHandler](reason =&gt; &#123; try&#123; const result = catchable(reason) resolve(result) &#125; catch(err) &#123; reject(err) &#125; &#125;, REJECTED, this[catchables]) &#125;) &#125; then(thenable, catchable) &#123; return this[linkPromise](thenable, catchable) &#125; catch(catchable) &#123; return this[linkPromise](undefined, catchable) &#125; &#125;&#125;)() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//优化const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus'), //改变状态 thenables = Symbol('thenables'), //resolve的消息队列 catchables = Symbol('catchables'), //rejecte的消息队列 settleHandler = Symbol('settleHandler'), //后续处理通用函数 linkPromise = Symbol('linkPromise') //串联时候创建一个新的Promise return class MyPromise &#123; //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue, queue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue queue.forEach(handler =&gt; handler(newValue)) &#125; constructor(executor) &#123; //executor为传入的函数 this[PromiseValue] = undefined this[PromiseStatus] = PENDING this[thenables] = [] this[catchables] = [] const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data, this[thenables]) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason, this[catchables]) &#125; try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; //后续处理通用函数 //handler: 要调用的处理函数 //immediatelyStatus： 需要立即执行的状态 //queue: 要加入的队列 [settleHandler](handler, immediatelyStatus, queue) &#123; if(typeof handler !== 'function') &#123; return &#125; if(this[PromiseStatus] === immediatelyStatus) &#123; setTimeout(() =&gt; &#123; handler(this[PromiseValue]) &#125;, 0) &#125;else &#123; //否则把处理函数加入resolve的消息队列 queue.push(handler) &#125; &#125; //当then返回一个promise时 //返回的promise的状态和状态数据都是由之前的promise决定的，所以要从之前的处理函数中得到状态数据,所以then中的处理函数要放到这个函数中执行 [linkPromise](thenable, catchable) &#123; //提起公共函数 function exec(data, handler, resolve, reject) &#123; try&#123; //如果得到的result是一个promise const result = handler(data) if(result instanceof MyPromise) &#123; //则执行这个promise result.then(res =&gt; &#123; //得到结果后一样执行resolve resolve(res) &#125;,err =&gt; &#123; reject(err) &#125;) &#125;else &#123; resolve(result) &#125; &#125; catch(err) &#123; reject(err) &#125; &#125; return new MyPromise((resolve, reject) =&gt; &#123; // this[settleHandler](thenable, RESOLVED, this[thenables]) //返回的状态数据由thenable的返回值决定，所以要拿到thenable的返回值 this[settleHandler](data =&gt; &#123; //相当于把thenable展开 exec(data, thenable, resolve, reject) &#125;, RESOLVED, this[thenables]) this[settleHandler](reason =&gt; &#123; exec(reason, catchable, resolve, reject) &#125;, REJECTED, this[catchables]) &#125;) &#125; then(thenable, catchable) &#123; return this[linkPromise](thenable, catchable) &#125; catch(catchable) &#123; return this[linkPromise](undefined, catchable) &#125; &#125;&#125;)() Promise的几个静态方法resolve12const pro = MyPromise.resolve(123)console.log(pro) 1234567891011//如果传入的是一个promise对象，直接返回//传入的是一个数据，则调用promise的resolve方法static resolve(data) &#123; if(typeof data === MyPromise) &#123; return data &#125;else &#123; return new MyPromise((resolve, reject) =&gt; &#123; resolve(data) &#125;) &#125;&#125; reject12const pro = MyPromise.reject(123)console.log(pro) 123456//reject则直接返回reject方法static reject(reason) &#123; return new MyPromise((resolve, reject) =&gt; &#123; reject(reason) &#125;)&#125; all1234567891011121314151617181920212223242526272829function getRandom(min, max) &#123; return Math.floor(Math.random() * (max - min)) + min;&#125;const proms = [];for (let i = 0; i &lt; 10; i++) &#123; proms.push(new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i, \"完成\"); resolve(i) // if (Math.random() &lt; 0.5) &#123; // console.log(i, \"完成\"); // resolve(i); // &#125; // else &#123; // console.log(i, \"失败\") // reject(i); // &#125; &#125;, getRandom(1000, 5000)); &#125;))&#125;//等到所有的promise变成resolved状态后输出: 全部完成const pro = MyPromise.all(proms)pro.then(datas =&gt; &#123; console.log(\"全部完成\", datas);&#125;)pro.catch(err =&gt; &#123; console.log(\"有失败的\", err);&#125;)console.log(proms); 1234567891011121314151617181920212223242526272829//当所有的promise完成之后返回一个新的promise//什么时候所有的promise全部完成呢？static all(proms) &#123; return new MyPromise((resolve, reject) =&gt; &#123; //先把proms映射成一个新的数组，包含每一个promise的结果和是否到达resolve状态 const results = proms.map(p =&gt; &#123; const obj = &#123; result: undefined, //初始 isResolved: false &#125; //什么时候改变状态呢？ 当执行then的时候 p.then(res =&gt; &#123; obj.result = res; obj.isResolved = true //什么全部promise都执行完呢，当数组里面的isResolved全部改成true的时候 //把results里面isResolved为false的放入一个新的数组 const hasUnResolved = results.filter(it =&gt; !it.isResolved) if(hasUnResolved.length === 0) &#123; //全部完成。可以resolve结果出去。把results重新映射成只有result结果的数组。 resolve(results.map(it =&gt; it.result)) &#125; &#125;,err =&gt; &#123; //如果有一个失败，则直接reject reject(err) &#125;) return obj &#125;) &#125;)&#125; race1234567891011121314151617181920212223242526function getRandom(min, max) &#123; return Math.floor(Math.random() * (max - min)) + min;&#125;const proms = [];for (let i = 0; i &lt; 10; i++) &#123; proms.push(new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (Math.random() &lt; 0.5) &#123; console.log(i, \"完成\"); resolve(i); &#125; else &#123; console.log(i, \"失败\") reject(i); &#125; &#125;, getRandom(1000, 5000)); &#125;))&#125;//等到所有的promise变成resolved状态后输出: 全部完成const pro = MyPromise.race(proms)pro.then(datas =&gt; &#123; console.log(\"有一个完成\", datas);&#125;)pro.catch(err =&gt; &#123; console.log(\"有一个失败\", err);&#125;)console.log(proms); 123456789101112static race(proms) &#123; return new MyPromise((resolve, reject) =&gt; &#123; //遍历proms，只要有一个状态到达resolve则resolve结果 proms.forEach(result =&gt; &#123; result.then(res =&gt; &#123; resolve(res) &#125;,err =&gt; &#123; reject(err) &#125;) &#125;) &#125;)&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus'), //改变状态 thenables = Symbol('thenables'), //resolve的消息队列 catchables = Symbol('catchables'), //rejecte的消息队列 settleHandler = Symbol('settleHandler'), //后续处理通用函数 linkPromise = Symbol('linkPromise') //串联时候创建一个新的Promise return class MyPromise &#123; //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue, queue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue queue.forEach(handler =&gt; handler(newValue)) &#125; constructor(executor) &#123; //executor为传入的函数 this[PromiseValue] = undefined this[PromiseStatus] = PENDING this[thenables] = [] this[catchables] = [] const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data, this[thenables]) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason, this[catchables]) &#125; try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; //后续处理通用函数 //handler: 要调用的处理函数 //immediatelyStatus： 需要立即执行的状态 //queue: 要加入的队列 [settleHandler](handler, immediatelyStatus, queue) &#123; if(typeof handler !== 'function') &#123; return &#125; if(this[PromiseStatus] === immediatelyStatus) &#123; setTimeout(() =&gt; &#123; handler(this[PromiseValue]) &#125;, 0) &#125;else &#123; //否则把处理函数加入resolve的消息队列 queue.push(handler) &#125; &#125; //当then返回一个promise时 //返回的promise的状态和状态数据都是由之前的promise决定的，所以要从之前的处理函数中得到状态数据,所以then中的处理函数要放到这个函数中执行 [linkPromise](thenable, catchable) &#123; //提起公共函数 function exec(data, handler, resolve, reject) &#123; try&#123; //如果得到的result是一个promise const result = handler(data) if(result instanceof MyPromise) &#123; //则执行这个promise result.then(res =&gt; &#123; //得到结果后一样执行resolve resolve(res) &#125;,err =&gt; &#123; reject(err) &#125;) &#125;else &#123; resolve(result) &#125; &#125; catch(err) &#123; reject(err) &#125; &#125; return new MyPromise((resolve, reject) =&gt; &#123; // this[settleHandler](thenable, RESOLVED, this[thenables]) //返回的状态数据由thenable的返回值决定，所以要拿到thenable的返回值 this[settleHandler](data =&gt; &#123; //相当于把thenable展开 exec(data, thenable, resolve, reject) &#125;, RESOLVED, this[thenables]) this[settleHandler](reason =&gt; &#123; exec(reason, catchable, resolve, reject) &#125;, REJECTED, this[catchables]) &#125;) &#125; then(thenable, catchable) &#123; return this[linkPromise](thenable, catchable) &#125; catch(catchable) &#123; return this[linkPromise](undefined, catchable) &#125; static resolve(data) &#123; if(typeof data === MyPromise) &#123; return data &#125;else &#123; return new MyPromise((resolve, reject) =&gt; &#123; resolve(data) &#125;) &#125; &#125; static reject(reason) &#123; return new MyPromise((resolve, reject) =&gt; &#123; reject(reason) &#125;) &#125; static all(proms) &#123; return new MyPromise((resolve, reject) =&gt; &#123; //先把proms映射成一个新的数组，包含每一个promise的结果和是否到达resolve状态 const results = proms.map(p =&gt; &#123; const obj = &#123; result: undefined, //初始 isResolved: false &#125; //什么时候改变状态呢？ 当执行then的时候 p.then(res =&gt; &#123; obj.result = res; obj.isResolved = true //什么全部promise都执行完呢，当数组里面的isResolved全部改成true的时候 //把results里面isResolved为false的放入一个新的数组 const hasUnResolved = results.filter(it =&gt; !it.isResolved) if(hasUnResolved.length === 0) &#123; //全部完成。可以resolve结果出去。把results重新映射成只有result结果的数组。 resolve(results.map(it =&gt; it.result)) &#125; &#125;,err =&gt; &#123; //如果有一个失败，则直接reject reject(err) &#125;) return obj &#125;) &#125;) &#125; static race(proms) &#123; return new MyPromise((resolve, reject) =&gt; &#123; //遍历proms，只要有一个状态到达resolve则resolve结果 proms.forEach(result =&gt; &#123; result.then(res =&gt; &#123; resolve(res) &#125;,err =&gt; &#123; reject(err) &#125;) &#125;) &#125;) &#125; &#125;&#125;)()","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"ES6 之 Promise的其他api","slug":"ES6-Promise的其他api","date":"2019-11-07T00:37:32.000Z","updated":"2019-11-13T03:19:01.716Z","comments":true,"path":"2019/11/07/ES6-Promise的其他api/","link":"","permalink":"http://yoursite.com/2019/11/07/ES6-Promise%E7%9A%84%E5%85%B6%E4%BB%96api/","excerpt":"","text":"Promise的其他api原型成员（实例成员） then：注册一个后续处理函数，当Promise为resolved状态时运行该函数 catch：注册一个后续处理函数，当Promise为rejected状态时运行该函数 finally：[ES2018]注册一个后续处理函数（无参），当Promise为已决时运行该函数（无论是resoleved或者rejected）1234567const pro = new Promise((res,rej) =&gt; &#123; res(1)&#125;)pro.finally(() =&gt; &#123;console.log('finally1')&#125;) pro.finally(() =&gt; &#123;console.log('finally2')&#125;)pro.then((res) =&gt; &#123;console.log('then',res)&#125;)// finally1 finally2 then,1 构造函数成员（静态成员） resolve(数据)：该方法返回一个resolved状态的Promise，传递的数据作为状态数据 特殊情况：如果传递的数据是Promise，则直接返回传递的Promise对象1234567891011const pro = new Promise((res,rej) =&gt; &#123; res(1)&#125;)pro.then(res =&gt; &#123; console.log('then',res)&#125;)//如果promise里面只有res没有其他操作可以等效于下面的写法const pro1 = Promise.resolve(2)pro1.then(res =&gt; &#123; console.log('then1',res)&#125;) 1234567//特殊情况const pro = new Promise((res,rej) =&gt; &#123; res(1)&#125;)const p = Promise.resolve(1)console.log(pro === p) //true reject(数据)：该方法返回一个rejected状态的Promise，传递的数据作为状态数据 12345//同上const pro1 = Promise.reject(3)pro1.catch(err =&gt; &#123; console.log('catch',err)&#125;) all(iterable)：这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。 12345678910111213141516171819202122const proms = []for (let i = 0; i &lt; 10; i++) &#123; const pro = new Promise((res,rej) =&gt; &#123; setTimeout(() =&gt; &#123; if(Math.random() &lt; 0.1) &#123; console.log(i,'success') res(i) &#125;else &#123; console.log(i,'fail') rej(i) &#125; &#125;, Math.floor(Math.random(3000 - 1000) + 1000)); &#125;) proms.push(pro) &#125;const pros = Promise.all(proms)pros.then(res =&gt; &#123; console.log(res,'都成功了') //全部成功才会返回都成功，res为每一个pro的返回值组成的数组。&#125;)pros.catch(err =&gt; &#123; console.log(err,'有失败的') //有一个失败即返回有失败的，err为第一个失败的返回值&#125;) race(iterable)：当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象12345678910111213141516171819202122const proms = []for (let i = 0; i &lt; 10; i++) &#123; const pro = new Promise((res,rej) =&gt; &#123; setTimeout(() =&gt; &#123; if(Math.random() &lt; 0.1) &#123; console.log(i,'success') res(i) &#125;else &#123; console.log(i,'fail') rej(i) &#125; &#125;, Math.floor(Math.random(3000 - 1000) + 1000)); &#125;) proms.push(pro) &#125;const pros = Promise.race(proms)pros.then(res =&gt; &#123; console.log(res,'有一个成功了') //有一个成功就会返回成功&#125;)pros.catch(err =&gt; &#123; console.log(err,'有一个失败了') //有一个失败即返回失败&#125;) 处理异步之间的联系 有一个需求需要其他异步全部处理完之后做的1234567891011121314151617181920212223242526272829303132333435363738function biaobai(god) &#123; //异步发送短信 return new Promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`向女神$&#123;god&#125;发送短信`) if (Math.random() &lt; 0.3) &#123; console.log(`$&#123;god&#125;同意`) res(true) &#125; else &#123; console.log(`$&#123;god&#125;拒绝`) res(false) &#125; &#125;, Math.floor(Math.random(3000 - 1000) + 1000)); &#125;)&#125;let hasAgree = false //全局变量记录第一个同意的女神const proms = [] for (let i = 0; i &lt; 10; i++) &#123; const pro = biaobai(`女神$&#123;i&#125;`).then(res =&gt; &#123; if (res) &#123; if (hasAgree) &#123; console.log('发错了短信') //已经有同意的女神 &#125; else &#123; hasAgree = true console.log(`太开心了`) //第一个同意的女神 &#125; &#125; return res //返回resolved状态的promise &#125;) proms.push(pro) //把所有的promise装入一个数组&#125;const pros = Promise.all(proms)pros.then(res =&gt; &#123; //所有的promise都到了resolve状态后打印日志 console.log('日志', res)&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"ES6 之 Promise（二）","slug":"es6-Promise2","date":"2019-11-06T11:00:27.000Z","updated":"2019-11-12T06:53:37.817Z","comments":true,"path":"2019/11/06/es6-Promise2/","link":"","permalink":"http://yoursite.com/2019/11/06/es6-Promise2/","excerpt":"","text":"Promise的串联当后续的Promise需要用到之前的Promise的处理结果时，需要Promise的串联。 Promise对象中，无论是then方法还是catch方法，它们都具有返回值，返回的是一个全新的Promise对象，它的状态满足下面的规则： 如果当前的Promise是未决的，得到的新的Promise是挂起状态（异步：例如ajax请求、定时器） 1234567891011const pro1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 3000);&#125;)console.log(pro1) //pendding pro1.then(result =&gt; &#123; console.log(pro1,\"结果出来了，得到的是一个Promise\") //resolved&#125;) 如果当前的Promise是已决的，会运行响应的后续处理函数，并将后续处理函数的结果（返回值）作为resolved状态数据，应用到新的Promise中；如果后续处理函数发生错误，则把返回值作为rejected状态数据，应用到新的Promise中。 123456789101112131415161718const pro1 = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;)const pro2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2); //把resolved作为状态数据到新的promise的数据中 &#125;, 3000);&#125;)pro1.then(result =&gt; &#123; console.log(\"结果出来了，得到的是一个Promise\",result) //pro1到resolved阶段，result为1 return pro2; &#125;).then(result =&gt; &#123; console.log(pro2,result) //相当于pro2.then(result=&gt;&#123;&#125;) pro2是已决状态，result为2&#125;).then(result =&gt; &#123; console.log(result) //因为pro2没有return,相当于return undefined //输出undefined&#125;) 1234567891011121314151617181920const pro1 = new Promise((resolve, reject) =&gt; &#123; throw 1; //推向rejected状态&#125;)const pro2 = pro1.then(result =&gt; &#123; return result * 2&#125;, err =&gt; &#123; return err * 3; //1*3 返回3 因为并没有报错，所以是作为下一个promise对象的resolved状态数据&#125;); //如果是throw err*3 则是作为下一个promise对象的rejected状态数据pro1.catch(err =&gt; &#123; //返回的是一个新的promise对象，跟pro2没关系 return err * 2;&#125;)console.log(pro2) //pendding//pro2类型：Promise对象//pro2的状态：pro2.then(result =&gt; console.log(pro2,result * 2), err =&gt; console.log(err * 3))//输出：resolved,6 后续的Promise一定会等到前面的Promise有了后续处理结果后，才会变成已决状态 123456789const pro1 = new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;)const pro2 = pro1.then(result =&gt; &#123; return result * 2 //只要当pro1的这句话执行完后pro2的状态才会变成已决&#125;, err =&gt; &#123; return err * 3;&#125;); 解决回调地狱问题12345678910111213141516171819202122232425262728293031323334353637function biaobai(god) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(`向$&#123;god&#125;发送短信`) setTimeout(() =&gt; &#123; if (Math.random() &lt; 0.1) &#123; resolve(true) &#125; else &#123; resolve(false) &#125; &#125;,500); &#125;)&#125;let gods = ['女神1', '女神2']let pro = nullfor (let index = 0; index &lt; gods.length; index++) &#123; if (index === 0) &#123; pro = biaobai(`$&#123;gods[0]&#125;`) &#125; pro = pro.then(res =&gt; &#123; if (res === undefined) &#123; //表示同意后或者最后一次都是return undefined return //return undefined &#125; else if (res) &#123; console.log(`$&#123;gods[index]&#125;同意了`) return //return undefined &#125; else &#123; console.log(`$&#123;gods[index]&#125;拒绝了`) if (index &lt; gods.length - 1) &#123; return biaobai(`$&#123;gods[index + 1]&#125;`) &#125; &#125; &#125;)&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"ES6 之 Promise（一）","slug":"es6-Promise1","date":"2019-11-05T11:14:50.000Z","updated":"2019-11-12T06:37:12.597Z","comments":true,"path":"2019/11/05/es6-Promise1/","link":"","permalink":"http://yoursite.com/2019/11/05/es6-Promise1/","excerpt":"","text":"前提我们习惯于使用传统的回调或事件处理来解决异步问题，但是随着前端工程越来越复杂，该模式面临以下两个问题： 回调地狱：某个异步操作需要等待之前的异步操作完成，无论用回调还是事件，都会陷入不断的嵌套 1234567891011121314151617181920212223242526272829303132333435//小A心中有三个女神//有一天，小A决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，//直到所有的女神都拒绝，或有一个女神同意为止function biaobai(god, callback) &#123; console.log(`小A向女神【$&#123;god&#125;】发出了表白短信`); setTimeout(() =&gt; &#123; if (Math.random() &lt; 0.1) &#123; callback(true); &#125; else &#123; callback(false); &#125; &#125;, 1000);&#125;biaobai(\"女神1\", function(result) &#123; if (result) &#123; console.log(\"女神1答应了，小A很开心!\") &#125; else &#123; console.log(\"女神1拒绝了，小A表示无压力，然后向女神2表白\"); biaobai(\"女神2\", function(result) &#123; if (result) &#123; console.log(\"女神2答应了，小A很开心!\") &#125; else &#123; console.log(\"女神2十分感动，然后拒绝了小A，小A向女神3表白\"); biaobai(\"女神3\", function(result) &#123; if (result) &#123; console.log(\"女神3答应了，小A很开心!\") &#125; else &#123; console.log(\"小A表示生无可恋!!\"); &#125; &#125;) &#125; &#125;) &#125;&#125;) 异步之间的联系：某个异步操作要等待多个异步操作的结果，对这种联系的处理，会让代码的复杂度剧增 1234567891011121314151617181920212223242526272829303132333435//当所有的女神回复完成后，他要把所有的回复都记录到日志进行分析//因为回复是异步的，所以不能放到函数末尾执行。function biaobai(god, callback) &#123; console.log(`小A向女神【$&#123;god&#125;】发出了表白短信`); setTimeout(() =&gt; &#123; if (Math.random() &lt; 0.05) &#123; callback(true); &#125; else &#123; callback(false); &#125; &#125;, Math.floor(Math.random() * (3000 - 1000) + 1000)); //模拟异步，每个女神回复的时间不同&#125;let agreeGod = null; //同意小A的第一个女神 （只能建立一个全局变量）const results = []; //用于记录回复结果的数组for (let i = 1; i &lt;= 20; i++) &#123; biaobai(`女神$&#123;i&#125;`, result =&gt; &#123; results.push(result); //每次向数组添加一个女神 if (result) &#123; console.log(`女神$&#123;i&#125;同意了`) if (agreeGod) &#123; console.log(`小A回复女神$&#123;i&#125;: 不好意思，刚才朋友用我手机，乱发的`) &#125; else &#123; agreeGod = `女神$&#123;i&#125;`; console.log(`小A终于找到了真爱`); &#125; &#125; else &#123; console.log(`女神$&#123;i&#125;拒绝了`) &#125; if (results.length === 20) &#123; console.log(\"日志记录\", results) //终于得到所有的日志 &#125; &#125;)&#125;//记录日志是一个单独的功能，这样穿插到代码中，会使代码易读性变差，并且日后添加其他模块的时候不好扩展或维护 ES官方参考了大量的异步场景，总结出了一套异步的通用模型，该模型可以覆盖几乎所有的异步场景，甚至是同步场景，也就是Promise。 通用模型 Promise的基本使用123456789101112131415161718192021const pro = new Promise((resolve, reject)=&gt;&#123; // 未决阶段的处理（同步，立即处理） // 通过调用resolve函数将Promise推向已决阶段的resolved状态或者调用reject函数将Promise推向已决阶段的rejected状态 // resolve和reject均可以传递最多一个参数，表示推向状态的数据 // resolve和reject均不可逆，resolve后再reject，reject不会执行&#125;)//第一种写法pro.then(data=&gt;&#123; //这是thenable函数，如果当前的Promise已经是resolved状态，该函数会立即执行 //如果当前是未决阶段，则会加入到作业队列，等待到达resolved状态后执行 //data为传出来的数据&#125;, err=&gt;&#123; //这是catchable函数，如果当前的Promise已经是rejected状态，该函数会立即执行 //如果当前是未决阶段，则会加入到作业队列，等待到达rejected状态后执行&#125;)//第二种写法pro.then(data=&gt;&#123; //同上&#125;).catch(err=&gt;&#123; //同上&#125;) 使用promise后： 12345678910111213141516function biaobai(god) &#123; return new Promise(resolve =&gt; &#123; console.log(`小A向$&#123;god&#125;发出了表白短信`); setTimeout(() =&gt; &#123; if (Math.random() &lt; 0.1) &#123; resolve(true) //不管是同意还是拒绝都是resolve &#125; else &#123; resolve(false); &#125; &#125;, 3000); &#125;)&#125;biaobai(\"女神1\").then(result =&gt; &#123; console.log(result);&#125;) 细节 未决阶段的处理函数是同步的，会立即执行 1234const pro = new Promise((res, rej) =&gt; &#123; console.log('未决阶段') //立即执行 res('data') &#125;) thenable和catchable函数是异步的，就算是立即执行，也会加入到事件队列中等待执行，并且，加入的队列是微队列 1234567const pro = new Promise((res, rej) =&gt; &#123; res(1) &#125;)pro.then(res =&gt; &#123; console.log(res) //异步，在微队列里&#125;)console.log(2) //输出 2 1 pro.then可以只添加thenable函数，pro.catch可以单独添加catchable函数 在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向rejected，并会被catchable捕获 12345678const pro = new Promise((res, rej) =&gt; &#123; throw new Error('ERROR') //可以把状态推向rejected res('data') //不会执行&#125;)pro.catch(err =&gt; &#123; console.log(err) //可以捕获到错误信息&#125;) 一旦状态推向了已决阶段，无法再对状态做任何更改 12345const pro = new Promise((res, rej) =&gt; &#123; res(1) //已经推向已决阶段 res(2)//不会执行 rej(3)//不会执行&#125;) Promise并没有消除回调，只是让回调变得可控 如何处理回调地狱请看下一篇 ES6 之 Promise（二）","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"异步处理 之 事件循环","slug":"异步处理之事件循环","date":"2019-11-04T12:56:58.000Z","updated":"2019-11-12T06:02:12.845Z","comments":true,"path":"2019/11/04/异步处理之事件循环/","link":"","permalink":"http://yoursite.com/2019/11/04/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"JS引擎对事件队列的取出执行方式，以及与宿主环境的配合，称之为事件循环。 宿主环境浏览器宿主环境中包含5个线程： JS引擎：负责执行执行栈的最顶部代码 GUI线程：负责渲染页面 事件监听线程：负责监听各种事件 计时线程：负责计时 网络线程：负责网络通信 JS运行的环境称之为宿主环境。 执行栈 执行栈：call stack，一个数据结构，用于存放各种函数的执行环境(执行上下文)。函数调用之前，创建执行上下文，然后加入到执行栈；函数调用之后，销毁执行上下文。 JS引擎永远执行的是执行栈的最顶部。 异步函数：某些函数不会立即执行，需要等到某个时机到达后才会执行，这样的函数称之为异步函数。比如事件处理函数。异步函数的执行时机，会被宿主环境控制。 事件队列当上面的线程发生了某些事请，如果该线程发现，这件事情有处理程序，它会将该处理程序加入一个叫做事件队列的内存。当JS引擎发现，执行栈中已经没有了任何内容后，会将事件队列中的第一个函数加入到执行栈中执行。 事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种： 宏任务（队列）：macroTask，计时器结束的回调、事件回调、http回调等等绝大部分异步函数进入宏队列 微任务（队列）：MutationObserver，Promise产生的回调进入微队列 MutationObserver用于监听某个DOM对象的变化 当执行栈清空时，JS引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务。 1234567891011121314 console.log(\"a\") setTimeout(function a() &#123; console.log('b') &#125;, 0); for (let i = 0; i &lt; 1000; i++) &#123; console.log(\"c\") &#125; // 输出a 1000个c b//首先创建一个全局上下文，然后创建log上下文，输出a，log上下文销毁。//创建一个settimeout上下文，把settimeout放到宿主环境中的其他线程进行执行，settimeout执行完，销毁上下文//当0秒后监听线程监听到settimeout到时，就会把函数a放入宏队列中//执行循环，创建log上下文，输出c，销毁log上下文，循环1000次。//执行栈里面没有内容，看队列，把队列的函数a放到执行栈中执行。输出b。//全局上下文结束，销毁全局上下文 执行栈 –&gt;(异步函数) 宿主环境 –&gt;(函数) 事件队列 –&gt;(函数) 执行栈 ==&gt;EventLoop","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"ES6 之 块级绑定","slug":"es6-块级绑定","date":"2019-11-03T10:24:40.000Z","updated":"2019-11-11T08:10:00.678Z","comments":true,"path":"2019/11/03/es6-块级绑定/","link":"","permalink":"http://yoursite.com/2019/11/03/es6-%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A/","excerpt":"","text":"用var声明变量的问题 允许重复的变量声明: 导致数据被覆盖 12var a = 1var a = 2 //后者覆盖前者 变量提升: 怪异的数据访问、闭包问题 1234567891011121314151617181920212223242526//怪异的数据访问if (Math.random() &lt; 0.5) &#123; var a = \"abc\"; console.log(a);&#125;else &#123; console.log(a); //没有声明a，但是不会报错 undefined&#125;console.log(a); //没有声明a，但是不会报错 undefined//闭包问题var div = document.getElementById(\"divButtons\")for (var i = 1; i &lt;= 10; i++) &#123; var btn = document.createElement(\"button\"); btn.innerHTML = \"按钮\" + i; div.appendChild(btn); btn.onclick = function () &#123; console.log(i); //输出11 &#125;&#125;// 循环结束后，i：11 // 因为var变量提升，每次var i = i，相当于把全局的i都覆盖了，而点击事件是异步的，点击的时候i全部为你11了 全局变量挂载到全局对象: 全局对象成员污染问题123var console = \"abc\";console.log(console) //var的时候相当于在window上添加属性，所以如果window有这个属性，则会被覆盖。 es6不仅引入let、const关键字用于解决变量声明的问题，同时引入了块级作用域的概念。 块级作用域： 代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域。（if 或 for的花括号） 使用let声明变量 let声明的变量不会挂载到全局对象，解决全局对象被污染问题 12let a = 123;console.log(window.a) //undefined let声明的变量，不允许当前作用域范围内重复声明，解决变量被覆盖问题 1234let a = 123;let a = 456; // ' Identifier 'b' has already been declared' //检查到，当前作用域（全局作用域）已声明了变量a let声明的变量不会变量提升：解决怪异的数据访问、闭包问题123456789101112131415161718192021if (Math.random() &lt; 0.5) &#123; let a = 123; //定义在当前块级作用域 console.log(a) //当前块级作用域中的a&#125;else &#123; //这是另外一个块级作用域，该作用域中找不到a console.log(a) //a is not defined&#125;console.log(a); //a is not defined//闭包let div = document.getElementById(\"divButtons\");for (let i = 1; i &lt;= 10; i++) &#123; //每次let都是创建一个新的块级作用域，里面i不会被覆盖。 let button = document.createElement(\"button\") button.innerHTML = \"按钮\" + i; button.onclick = function () &#123; console.log(i) //使用的是当前作用域中的i &#125; div.appendChild(button)&#125; 底层实现上，let声明的变量实际也会有提升，但是，提升后会将其放入‘暂时性死区’，如果访问的变量位于暂时性死区，则会报错‘Cannot access ‘a’ before initialization’,当代码运行到该变量的声明语句时，会将其从暂时性死区中移除。 在循环中，用let声明的循环变量，会特殊处理，每次进入循环体，都会开启一个新的作用域，并且将循环变量绑定到该作用域。在循环中使用的let声明的循环变量，在循环结束后会销毁。 使用const声明变量和let完全相同，仅在于用const声明的变量，必须在声明时赋值，并且不可以重新赋值。 注意 常量不可变，是指声明常量的内存空间不可变，并不保证内存空间中的地址指向的其他空间不可变。 12345678910const a = &#123; name: '123', age: 18&#125;a.name = 456 //不会报错a = &#123; name: 456, age: 18&#125; //赋值了一个新的地址，会报错 常量的命名 特殊的常量：该常量从字面意义上，一定是不可变的。（圆周率、月地距离），通常该常量的名称全部使用大写，多个单词之间用下划线分割（PI、MOON_DIS） 普通的常量：使用和之前一样的命名即可 在for循环中，循环变量不能使用常量","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"ES6 之 概述","slug":"es6概述","date":"2019-11-02T11:45:39.000Z","updated":"2019-11-14T07:47:19.341Z","comments":true,"path":"2019/11/02/es6概述/","link":"","permalink":"http://yoursite.com/2019/11/02/es6%E6%A6%82%E8%BF%B0/","excerpt":"","text":"ES6概述ECMAScript、JavaScript、NodeJs，它们的区别是什么？ECMAScript：简称ES，是一个语言标准（循环、判断、变量、数组等数据类型） JavaScript：运行在浏览器端的语言，该语言使用ES标准。 ES + web api = JavaScript NodeJs：运行在服务器端的语言，该语言使用ES标准。 ES + node api = NodeJs 无论JavaScript，还是NodeJs，它们都是ES的超集（super set） ECMAScript有哪些关键的版本？ES3.0:1999 ES5.0:2009 ES6.0:2015, 从该版本开始，不再使用数字作为编号，而使用年份 ES7.0:2016 为什么ES6如此重要？ES6解决JS无法开发大型应用的语言层面的问题。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]}]}