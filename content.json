{"meta":{"title":"W。的个人博客","subtitle":"只想做一只安静的程序猿","description":"","author":"W。","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-11-11T00:53:54.000Z","updated":"2019-11-11T00:54:12.947Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-11-11T00:54:23.000Z","updated":"2019-11-11T00:54:38.647Z","comments":true,"path":"link/index.html","permalink":"http://yoursite.com/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-11T00:53:14.000Z","updated":"2019-11-11T00:53:41.229Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ES6 之 手写Promise","slug":"ES6-手写Promise","date":"2019-11-08T03:20:09.000Z","updated":"2019-11-15T02:22:03.168Z","comments":true,"path":"2019/11/08/ES6-手写Promise/","link":"","permalink":"http://yoursite.com/2019/11/08/ES6-%E6%89%8B%E5%86%99Promise/","excerpt":"","text":"未决阶段推向已决阶段Promise是一个构造函数，接收一个函数，函数有两个参数（resolve,reject），也是两个函数。resolve 和 reject 作用就是调用的时候是把未决阶段推向已决，也就是改变promise的状态，并且附上返回值。 12345const pro = new MyPromise((resolve, reject) =&gt; &#123; console.log('执行未决阶段的代码') resolve(1)&#125;)console.log(pro) 12345678910111213141516171819202122232425262728293031323334353637383940//写成立即执行函数，设置私有变量。const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', //设置为symbol，不让外界调用 PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus') //当前状态 return class MyPromise &#123; constructor(executor) &#123; //executor为传入的函数 //初始化数据 this[PromiseValue] = undefined this[PromiseStatus] = PENDING //resolve调用就两个作用：改变状态，设置返回值 const resolve = data =&gt; &#123; //写成箭头函数，避免this的问题 //如果当前的状态不是pending，就直接return。（promise只要状态是已决，就不能再改变） if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseValue] = data //设置数据 this[PromiseStatus] = RESOLVED //改变状态 &#125; //reject跟resolve一样 const reject = reason =&gt; &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseValue] = reason this[PromiseStatus] = REJECTED &#125; //executor在初始化的时候调用了一次 executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; &#125;&#125;)() 1234567891011121314151617181920212223242526272829303132333435363738//上面的代码有重复的部分，我们先优化一下 ---优化后const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus') //改变状态 return class MyPromise &#123; //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue &#125; constructor(executor) &#123; //executor为传入的函数 //初始化数据 this[PromiseValue] = undefined this[PromiseStatus] = PENDING //抽取了跟reject的公共代码。 const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason) &#125; //executor在初始化的时候调用了一次 executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; &#125;&#125;)() 解决throw问题除了reject函数可以把未决阶段推向rejected状态，throw也可以。 12345const pro = new MyPromise((resolve, reject) =&gt; &#123; console.log('执行未决阶段的代码') throw new Error('推向rejected状态')&#125;)console.log(pro) 12345678910111213141516171819202122232425262728293031323334353637383940const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus') //改变状态 return class MyPromise &#123; [changeStatus](newStatus, newValue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue &#125; constructor(executor) &#123; //executor为传入的函数 //初始化数据 this[PromiseValue] = undefined this[PromiseStatus] = PENDING //抽取了跟reject的公共代码。 const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason) &#125; //executor在初始化的时候调用了一次 //如果传入的是一个throw 'xxx' try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; &#125;&#125;)() 处理then和catch考虑两个问题： 什么时候往事件队列里面加处理函数？如果当前状态已经到达已决，执行处理函数，否则，把处理函数加入消息队列。 什么时候执行事件队列里面的处理函数？当状态改变的时候。 解决第一个问题：什么时候往事件队列里面加处理函数？ 123456789const pro = new MyPromise((resolve, reject) =&gt; &#123; console.log('执行未决阶段的代码') resolve(23)&#125;)//同步，当前状态到达已决pro.then(res =&gt; &#123; console.log(res)&#125;)console.log(pro) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus'), //改变状态 //新增 thenables = Symbol('thenables'), //resolve的消息队列 catchables = Symbol('catchables') //rejecte的消息队列 return class MyPromise &#123; //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue &#125; constructor(executor) &#123; //executor为传入的函数 this[PromiseValue] = undefined this[PromiseStatus] = PENDING //新增 //初始化队列 this[thenables] = [] this[catchables] = [] const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason) &#125; try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; //then函数，接收两个处理函数(resolved和rejected两个状态的) then(thenable, catchable) &#123; //如果当前状态是resolved,表示已经到达已决状态，用setTimeout模拟进入微队列。因为微队列是底层实现的，所以虽然setTimeout是宏队列，也只能用这个模拟。 if(this[PromiseStatus] === RESOLVED) &#123; setTimeout(() =&gt; &#123; thenable(this[PromiseValue]) &#125;, 0) &#125;else &#123; //否则把处理函数加入resolve的消息队列 this[thenables].push(thenable) &#125; //rejected状态则调用catch this.catch(catchable) &#125; //同上 catch(catchable) &#123; if(this[PromiseStatus] === REJECTED) &#123; setTimeout(() =&gt; &#123; catchable(this[PromiseValue]) &#125;, 0) &#125;else &#123; this[catchables].push(catchable) &#125; &#125; &#125;&#125;)() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//优化代码const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus'), //改变状态 thenables = Symbol('thenables'), //resolve的消息队列 catchables = Symbol('catchables'), //rejecte的消息队列 //新增 settleHandler = Symbol('settleHandler') //后续处理通用函数 return class MyPromise &#123; //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue &#125; constructor(executor) &#123; //executor为传入的函数 this[PromiseValue] = undefined this[PromiseStatus] = PENDING //初始化队列 this[thenables] = [] this[catchables] = [] const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason) &#125; try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; //新增 //后续处理通用函数 //handler: 要调用的处理函数 //immediatelyStatus： 需要立即执行的状态 //queue: 要加入的队列 [settleHandler](handler, immediatelyStatus, queue) &#123; if(this[PromiseStatus] === immediatelyStatus) &#123; setTimeout(() =&gt; &#123; handler(this[PromiseValue]) &#125;, 0) &#125;else &#123; //否则把处理函数加入resolve的消息队列 queue.push(handler) &#125; &#125; then(thenable, catchable) &#123; //提取出了公共函数 this[settleHandler](thenable, RESOLVED, this[thenables]) this.catch(catchable) &#125; catch(catchable) &#123; this[settleHandler](catchable, REJECTED, this[catchables]) &#125; &#125;&#125;)() 解决第二个问题：什么时候执行事件队列里面的处理函数？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus'), //改变状态 thenables = Symbol('thenables'), //resolve的消息队列 catchables = Symbol('catchables'), //rejecte的消息队列 settleHandler = Symbol('settleHandler') //后续处理通用函数 return class MyPromise &#123; //新增 加一个队列参数，当状态改变的时候，执行队列中的处理函数 //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue, queue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue queue.forEach(handler =&gt; handler(newValue)) &#125; constructor(executor) &#123; //executor为传入的函数 this[PromiseValue] = undefined this[PromiseStatus] = PENDING //初始化队列 this[thenables] = [] this[catchables] = [] //新增参数，resolve的消息队列 const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data, this[thenables]) &#125; //新增参数，reject的消息队列 const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason, this[catchables]) &#125; try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; //后续处理通用函数 //handler: 要调用的处理函数 //immediatelyStatus： 需要立即执行的状态 //queue: 要加入的队列 [settleHandler](handler, immediatelyStatus, queue) &#123; //新增：如果传入的处理函数不是function类型的，则直接返回 if(typeof handler !== 'function') &#123; return &#125; if(this[PromiseStatus] === immediatelyStatus) &#123; setTimeout(() =&gt; &#123; handler(this[PromiseValue]) &#125;, 0) &#125;else &#123; //否则把处理函数加入resolve的消息队列 queue.push(handler) &#125; &#125; then(thenable, catchable) &#123; this[settleHandler](thenable, RESOLVED, this[thenables]) this.catch(catchable) &#125; catch(catchable) &#123; this[settleHandler](catchable, REJECTED, this[catchables]) &#125; &#125;&#125;)() 链式调用（串联）12345678910111213141516const pro = new MyPromise((resolve, reject) =&gt; &#123; console.log('执行未决阶段的代码') resolve(123) &#125;) pro.then(res =&gt; &#123; console.log(1, res) return 456 &#125;).then(res =&gt; &#123; return new MyPromise((resolve, reject) =&gt; &#123; console.log(2,res) resolve(666) &#125;) &#125;).then(res =&gt; &#123; console.log(3,res) &#125;) //1 123 2 456 3 666 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus'), //改变状态 thenables = Symbol('thenables'), //resolve的消息队列 catchables = Symbol('catchables'), //rejecte的消息队列 settleHandler = Symbol('settleHandler'), //后续处理通用函数 //新增 linkPromise = Symbol('linkPromise') //串联时候创建一个新的Promise return class MyPromise &#123; //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue, queue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue queue.forEach(handler =&gt; handler(newValue)) &#125; constructor(executor) &#123; //executor为传入的函数 this[PromiseValue] = undefined this[PromiseStatus] = PENDING this[thenables] = [] this[catchables] = [] const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data, this[thenables]) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason, this[catchables]) &#125; try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; //后续处理通用函数 //handler: 要调用的处理函数 //immediatelyStatus： 需要立即执行的状态 //queue: 要加入的队列 [settleHandler](handler, immediatelyStatus, queue) &#123; if(typeof handler !== 'function') &#123; return &#125; if(this[PromiseStatus] === immediatelyStatus) &#123; setTimeout(() =&gt; &#123; handler(this[PromiseValue]) &#125;, 0) &#125;else &#123; //否则把处理函数加入resolve的消息队列 queue.push(handler) &#125; &#125; //当then返回一个promise时 //返回的promise的状态和状态数据都是由之前的promise决定的，所以要从之前的处理函数中得到状态数据,所以then中的处理函数要放到这个函数中执行 [linkPromise](thenable, catchable) &#123; return new MyPromise((resolve, reject) =&gt; &#123; // this[settleHandler](thenable, RESOLVED, this[thenables]) //返回的状态数据由thenable的返回值决定，所以要拿到thenable的返回值 this[settleHandler](data =&gt; &#123; //相当于把thenable展开 try&#123; const result = thenable(data) //当前promise的返回值 resolve(result) &#125; catch(err) &#123; //执行过程中出现问题，标记为reject reject(err) &#125; &#125;, RESOLVED, this[thenables]) this[settleHandler](reason =&gt; &#123; try&#123; const result = catchable(reason) resolve(result) &#125; catch(err) &#123; reject(err) &#125; &#125;, REJECTED, this[catchables]) &#125;) &#125; then(thenable, catchable) &#123; return this[linkPromise](thenable, catchable) &#125; catch(catchable) &#123; return this[linkPromise](undefined, catchable) &#125; &#125;&#125;)() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//优化const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus'), //改变状态 thenables = Symbol('thenables'), //resolve的消息队列 catchables = Symbol('catchables'), //rejecte的消息队列 settleHandler = Symbol('settleHandler'), //后续处理通用函数 linkPromise = Symbol('linkPromise') //串联时候创建一个新的Promise return class MyPromise &#123; //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue, queue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue queue.forEach(handler =&gt; handler(newValue)) &#125; constructor(executor) &#123; //executor为传入的函数 this[PromiseValue] = undefined this[PromiseStatus] = PENDING this[thenables] = [] this[catchables] = [] const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data, this[thenables]) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason, this[catchables]) &#125; try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; //后续处理通用函数 //handler: 要调用的处理函数 //immediatelyStatus： 需要立即执行的状态 //queue: 要加入的队列 [settleHandler](handler, immediatelyStatus, queue) &#123; if(typeof handler !== 'function') &#123; return &#125; if(this[PromiseStatus] === immediatelyStatus) &#123; setTimeout(() =&gt; &#123; handler(this[PromiseValue]) &#125;, 0) &#125;else &#123; //否则把处理函数加入resolve的消息队列 queue.push(handler) &#125; &#125; //当then返回一个promise时 //返回的promise的状态和状态数据都是由之前的promise决定的，所以要从之前的处理函数中得到状态数据,所以then中的处理函数要放到这个函数中执行 [linkPromise](thenable, catchable) &#123; //提起公共函数 function exec(data, handler, resolve, reject) &#123; try&#123; //如果得到的result是一个promise const result = handler(data) if(result instanceof MyPromise) &#123; //则执行这个promise result.then(res =&gt; &#123; //得到结果后一样执行resolve resolve(res) &#125;,err =&gt; &#123; reject(err) &#125;) &#125;else &#123; resolve(result) &#125; &#125; catch(err) &#123; reject(err) &#125; &#125; return new MyPromise((resolve, reject) =&gt; &#123; // this[settleHandler](thenable, RESOLVED, this[thenables]) //返回的状态数据由thenable的返回值决定，所以要拿到thenable的返回值 this[settleHandler](data =&gt; &#123; //相当于把thenable展开 exec(data, thenable, resolve, reject) &#125;, RESOLVED, this[thenables]) this[settleHandler](reason =&gt; &#123; exec(reason, catchable, resolve, reject) &#125;, REJECTED, this[catchables]) &#125;) &#125; then(thenable, catchable) &#123; return this[linkPromise](thenable, catchable) &#125; catch(catchable) &#123; return this[linkPromise](undefined, catchable) &#125; &#125;&#125;)() Promise的几个静态方法resolve12const pro = MyPromise.resolve(123)console.log(pro) 1234567891011//如果传入的是一个promise对象，直接返回//传入的是一个数据，则调用promise的resolve方法static resolve(data) &#123; if(typeof data === MyPromise) &#123; return data &#125;else &#123; return new MyPromise((resolve, reject) =&gt; &#123; resolve(data) &#125;) &#125;&#125; reject12const pro = MyPromise.reject(123)console.log(pro) 123456//reject则直接返回reject方法static reject(reason) &#123; return new MyPromise((resolve, reject) =&gt; &#123; reject(reason) &#125;)&#125; all1234567891011121314151617181920212223242526272829function getRandom(min, max) &#123; return Math.floor(Math.random() * (max - min)) + min;&#125;const proms = [];for (let i = 0; i &lt; 10; i++) &#123; proms.push(new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i, \"完成\"); resolve(i) // if (Math.random() &lt; 0.5) &#123; // console.log(i, \"完成\"); // resolve(i); // &#125; // else &#123; // console.log(i, \"失败\") // reject(i); // &#125; &#125;, getRandom(1000, 5000)); &#125;))&#125;//等到所有的promise变成resolved状态后输出: 全部完成const pro = MyPromise.all(proms)pro.then(datas =&gt; &#123; console.log(\"全部完成\", datas);&#125;)pro.catch(err =&gt; &#123; console.log(\"有失败的\", err);&#125;)console.log(proms); 1234567891011121314151617181920212223242526272829//当所有的promise完成之后返回一个新的promise//什么时候所有的promise全部完成呢？static all(proms) &#123; return new MyPromise((resolve, reject) =&gt; &#123; //先把proms映射成一个新的数组，包含每一个promise的结果和是否到达resolve状态 const results = proms.map(p =&gt; &#123; const obj = &#123; result: undefined, //初始 isResolved: false &#125; //什么时候改变状态呢？ 当执行then的时候 p.then(res =&gt; &#123; obj.result = res; obj.isResolved = true //什么全部promise都执行完呢，当数组里面的isResolved全部改成true的时候 //把results里面isResolved为false的放入一个新的数组 const hasUnResolved = results.filter(it =&gt; !it.isResolved) if(hasUnResolved.length === 0) &#123; //全部完成。可以resolve结果出去。把results重新映射成只有result结果的数组。 resolve(results.map(it =&gt; it.result)) &#125; &#125;,err =&gt; &#123; //如果有一个失败，则直接reject reject(err) &#125;) return obj &#125;) &#125;)&#125; race1234567891011121314151617181920212223242526function getRandom(min, max) &#123; return Math.floor(Math.random() * (max - min)) + min;&#125;const proms = [];for (let i = 0; i &lt; 10; i++) &#123; proms.push(new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (Math.random() &lt; 0.5) &#123; console.log(i, \"完成\"); resolve(i); &#125; else &#123; console.log(i, \"失败\") reject(i); &#125; &#125;, getRandom(1000, 5000)); &#125;))&#125;//等到所有的promise变成resolved状态后输出: 全部完成const pro = MyPromise.race(proms)pro.then(datas =&gt; &#123; console.log(\"有一个完成\", datas);&#125;)pro.catch(err =&gt; &#123; console.log(\"有一个失败\", err);&#125;)console.log(proms); 123456789101112static race(proms) &#123; return new MyPromise((resolve, reject) =&gt; &#123; //遍历proms，只要有一个状态到达resolve则resolve结果 proms.forEach(result =&gt; &#123; result.then(res =&gt; &#123; resolve(res) &#125;,err =&gt; &#123; reject(err) &#125;) &#125;) &#125;)&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164const MyPromise = (() =&gt; &#123; const PENDING = 'pending', //状态设置为常量 RESOLVED = 'resolved', REJECTED = 'rejected', PromiseValue = Symbol('PromiseValue'), //状态数据 PromiseStatus = Symbol('PromiseStatus'), //当前状态 changeStatus = Symbol('changeStatus'), //改变状态 thenables = Symbol('thenables'), //resolve的消息队列 catchables = Symbol('catchables'), //rejecte的消息队列 settleHandler = Symbol('settleHandler'), //后续处理通用函数 linkPromise = Symbol('linkPromise') //串联时候创建一个新的Promise return class MyPromise &#123; //公共函数 //改变状态： newStatus：将要改变的状态，newValue：要改变的状态数据 [changeStatus](newStatus, newValue, queue) &#123; if(this[PromiseStatus] !== PENDING) &#123; return &#125; this[PromiseStatus] = newStatus this[PromiseValue] = newValue queue.forEach(handler =&gt; handler(newValue)) &#125; constructor(executor) &#123; //executor为传入的函数 this[PromiseValue] = undefined this[PromiseStatus] = PENDING this[thenables] = [] this[catchables] = [] const resolve = data =&gt; &#123; this[changeStatus](RESOLVED, data, this[thenables]) &#125; const reject = reason =&gt; &#123; this[changeStatus](REJECTED, reason, this[catchables]) &#125; try&#123; executor(resolve, reject) //带有两个参数，我们自己定义这两个参数 &#125; catch(err) &#123; reject(err) //在这里捕获 &#125; &#125; //后续处理通用函数 //handler: 要调用的处理函数 //immediatelyStatus： 需要立即执行的状态 //queue: 要加入的队列 [settleHandler](handler, immediatelyStatus, queue) &#123; if(typeof handler !== 'function') &#123; return &#125; if(this[PromiseStatus] === immediatelyStatus) &#123; setTimeout(() =&gt; &#123; handler(this[PromiseValue]) &#125;, 0) &#125;else &#123; //否则把处理函数加入resolve的消息队列 queue.push(handler) &#125; &#125; //当then返回一个promise时 //返回的promise的状态和状态数据都是由之前的promise决定的，所以要从之前的处理函数中得到状态数据,所以then中的处理函数要放到这个函数中执行 [linkPromise](thenable, catchable) &#123; //提起公共函数 function exec(data, handler, resolve, reject) &#123; try&#123; //如果得到的result是一个promise const result = handler(data) if(result instanceof MyPromise) &#123; //则执行这个promise result.then(res =&gt; &#123; //得到结果后一样执行resolve resolve(res) &#125;,err =&gt; &#123; reject(err) &#125;) &#125;else &#123; resolve(result) &#125; &#125; catch(err) &#123; reject(err) &#125; &#125; return new MyPromise((resolve, reject) =&gt; &#123; // this[settleHandler](thenable, RESOLVED, this[thenables]) //返回的状态数据由thenable的返回值决定，所以要拿到thenable的返回值 this[settleHandler](data =&gt; &#123; //相当于把thenable展开 exec(data, thenable, resolve, reject) &#125;, RESOLVED, this[thenables]) this[settleHandler](reason =&gt; &#123; exec(reason, catchable, resolve, reject) &#125;, REJECTED, this[catchables]) &#125;) &#125; then(thenable, catchable) &#123; return this[linkPromise](thenable, catchable) &#125; catch(catchable) &#123; return this[linkPromise](undefined, catchable) &#125; static resolve(data) &#123; if(typeof data === MyPromise) &#123; return data &#125;else &#123; return new MyPromise((resolve, reject) =&gt; &#123; resolve(data) &#125;) &#125; &#125; static reject(reason) &#123; return new MyPromise((resolve, reject) =&gt; &#123; reject(reason) &#125;) &#125; static all(proms) &#123; return new MyPromise((resolve, reject) =&gt; &#123; //先把proms映射成一个新的数组，包含每一个promise的结果和是否到达resolve状态 const results = proms.map(p =&gt; &#123; const obj = &#123; result: undefined, //初始 isResolved: false &#125; //什么时候改变状态呢？ 当执行then的时候 p.then(res =&gt; &#123; obj.result = res; obj.isResolved = true //什么全部promise都执行完呢，当数组里面的isResolved全部改成true的时候 //把results里面isResolved为false的放入一个新的数组 const hasUnResolved = results.filter(it =&gt; !it.isResolved) if(hasUnResolved.length === 0) &#123; //全部完成。可以resolve结果出去。把results重新映射成只有result结果的数组。 resolve(results.map(it =&gt; it.result)) &#125; &#125;,err =&gt; &#123; //如果有一个失败，则直接reject reject(err) &#125;) return obj &#125;) &#125;) &#125; static race(proms) &#123; return new MyPromise((resolve, reject) =&gt; &#123; //遍历proms，只要有一个状态到达resolve则resolve结果 proms.forEach(result =&gt; &#123; result.then(res =&gt; &#123; resolve(res) &#125;,err =&gt; &#123; reject(err) &#125;) &#125;) &#125;) &#125; &#125;&#125;)()","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"ES6 之 Promise的其他api","slug":"ES6-Promise的其他api","date":"2019-11-07T00:37:32.000Z","updated":"2019-11-13T03:19:01.716Z","comments":true,"path":"2019/11/07/ES6-Promise的其他api/","link":"","permalink":"http://yoursite.com/2019/11/07/ES6-Promise%E7%9A%84%E5%85%B6%E4%BB%96api/","excerpt":"","text":"Promise的其他api原型成员（实例成员） then：注册一个后续处理函数，当Promise为resolved状态时运行该函数 catch：注册一个后续处理函数，当Promise为rejected状态时运行该函数 finally：[ES2018]注册一个后续处理函数（无参），当Promise为已决时运行该函数（无论是resoleved或者rejected）1234567const pro = new Promise((res,rej) =&gt; &#123; res(1)&#125;)pro.finally(() =&gt; &#123;console.log('finally1')&#125;) pro.finally(() =&gt; &#123;console.log('finally2')&#125;)pro.then((res) =&gt; &#123;console.log('then',res)&#125;)// finally1 finally2 then,1 构造函数成员（静态成员） resolve(数据)：该方法返回一个resolved状态的Promise，传递的数据作为状态数据 特殊情况：如果传递的数据是Promise，则直接返回传递的Promise对象1234567891011const pro = new Promise((res,rej) =&gt; &#123; res(1)&#125;)pro.then(res =&gt; &#123; console.log('then',res)&#125;)//如果promise里面只有res没有其他操作可以等效于下面的写法const pro1 = Promise.resolve(2)pro1.then(res =&gt; &#123; console.log('then1',res)&#125;) 1234567//特殊情况const pro = new Promise((res,rej) =&gt; &#123; res(1)&#125;)const p = Promise.resolve(1)console.log(pro === p) //true reject(数据)：该方法返回一个rejected状态的Promise，传递的数据作为状态数据 12345//同上const pro1 = Promise.reject(3)pro1.catch(err =&gt; &#123; console.log('catch',err)&#125;) all(iterable)：这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。 12345678910111213141516171819202122const proms = []for (let i = 0; i &lt; 10; i++) &#123; const pro = new Promise((res,rej) =&gt; &#123; setTimeout(() =&gt; &#123; if(Math.random() &lt; 0.1) &#123; console.log(i,'success') res(i) &#125;else &#123; console.log(i,'fail') rej(i) &#125; &#125;, Math.floor(Math.random(3000 - 1000) + 1000)); &#125;) proms.push(pro) &#125;const pros = Promise.all(proms)pros.then(res =&gt; &#123; console.log(res,'都成功了') //全部成功才会返回都成功，res为每一个pro的返回值组成的数组。&#125;)pros.catch(err =&gt; &#123; console.log(err,'有失败的') //有一个失败即返回有失败的，err为第一个失败的返回值&#125;) race(iterable)：当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象12345678910111213141516171819202122const proms = []for (let i = 0; i &lt; 10; i++) &#123; const pro = new Promise((res,rej) =&gt; &#123; setTimeout(() =&gt; &#123; if(Math.random() &lt; 0.1) &#123; console.log(i,'success') res(i) &#125;else &#123; console.log(i,'fail') rej(i) &#125; &#125;, Math.floor(Math.random(3000 - 1000) + 1000)); &#125;) proms.push(pro) &#125;const pros = Promise.race(proms)pros.then(res =&gt; &#123; console.log(res,'有一个成功了') //有一个成功就会返回成功&#125;)pros.catch(err =&gt; &#123; console.log(err,'有一个失败了') //有一个失败即返回失败&#125;) 处理异步之间的联系 有一个需求需要其他异步全部处理完之后做的1234567891011121314151617181920212223242526272829303132333435363738function biaobai(god) &#123; //异步发送短信 return new Promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`向女神$&#123;god&#125;发送短信`) if (Math.random() &lt; 0.3) &#123; console.log(`$&#123;god&#125;同意`) res(true) &#125; else &#123; console.log(`$&#123;god&#125;拒绝`) res(false) &#125; &#125;, Math.floor(Math.random(3000 - 1000) + 1000)); &#125;)&#125;let hasAgree = false //全局变量记录第一个同意的女神const proms = [] for (let i = 0; i &lt; 10; i++) &#123; const pro = biaobai(`女神$&#123;i&#125;`).then(res =&gt; &#123; if (res) &#123; if (hasAgree) &#123; console.log('发错了短信') //已经有同意的女神 &#125; else &#123; hasAgree = true console.log(`太开心了`) //第一个同意的女神 &#125; &#125; return res //返回resolved状态的promise &#125;) proms.push(pro) //把所有的promise装入一个数组&#125;const pros = Promise.all(proms)pros.then(res =&gt; &#123; //所有的promise都到了resolve状态后打印日志 console.log('日志', res)&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"ES6 之 Promise（二）","slug":"es6-Promise2","date":"2019-11-06T11:00:27.000Z","updated":"2019-11-12T06:53:37.817Z","comments":true,"path":"2019/11/06/es6-Promise2/","link":"","permalink":"http://yoursite.com/2019/11/06/es6-Promise2/","excerpt":"","text":"Promise的串联当后续的Promise需要用到之前的Promise的处理结果时，需要Promise的串联。 Promise对象中，无论是then方法还是catch方法，它们都具有返回值，返回的是一个全新的Promise对象，它的状态满足下面的规则： 如果当前的Promise是未决的，得到的新的Promise是挂起状态（异步：例如ajax请求、定时器） 1234567891011const pro1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 3000);&#125;)console.log(pro1) //pendding pro1.then(result =&gt; &#123; console.log(pro1,\"结果出来了，得到的是一个Promise\") //resolved&#125;) 如果当前的Promise是已决的，会运行响应的后续处理函数，并将后续处理函数的结果（返回值）作为resolved状态数据，应用到新的Promise中；如果后续处理函数发生错误，则把返回值作为rejected状态数据，应用到新的Promise中。 123456789101112131415161718const pro1 = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;)const pro2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2); //把resolved作为状态数据到新的promise的数据中 &#125;, 3000);&#125;)pro1.then(result =&gt; &#123; console.log(\"结果出来了，得到的是一个Promise\",result) //pro1到resolved阶段，result为1 return pro2; &#125;).then(result =&gt; &#123; console.log(pro2,result) //相当于pro2.then(result=&gt;&#123;&#125;) pro2是已决状态，result为2&#125;).then(result =&gt; &#123; console.log(result) //因为pro2没有return,相当于return undefined //输出undefined&#125;) 1234567891011121314151617181920const pro1 = new Promise((resolve, reject) =&gt; &#123; throw 1; //推向rejected状态&#125;)const pro2 = pro1.then(result =&gt; &#123; return result * 2&#125;, err =&gt; &#123; return err * 3; //1*3 返回3 因为并没有报错，所以是作为下一个promise对象的resolved状态数据&#125;); //如果是throw err*3 则是作为下一个promise对象的rejected状态数据pro1.catch(err =&gt; &#123; //返回的是一个新的promise对象，跟pro2没关系 return err * 2;&#125;)console.log(pro2) //pendding//pro2类型：Promise对象//pro2的状态：pro2.then(result =&gt; console.log(pro2,result * 2), err =&gt; console.log(err * 3))//输出：resolved,6 后续的Promise一定会等到前面的Promise有了后续处理结果后，才会变成已决状态 123456789const pro1 = new Promise((resolve, reject) =&gt; &#123; resolve(1)&#125;)const pro2 = pro1.then(result =&gt; &#123; return result * 2 //只要当pro1的这句话执行完后pro2的状态才会变成已决&#125;, err =&gt; &#123; return err * 3;&#125;); 解决回调地狱问题12345678910111213141516171819202122232425262728293031323334353637function biaobai(god) &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(`向$&#123;god&#125;发送短信`) setTimeout(() =&gt; &#123; if (Math.random() &lt; 0.1) &#123; resolve(true) &#125; else &#123; resolve(false) &#125; &#125;,500); &#125;)&#125;let gods = ['女神1', '女神2']let pro = nullfor (let index = 0; index &lt; gods.length; index++) &#123; if (index === 0) &#123; pro = biaobai(`$&#123;gods[0]&#125;`) &#125; pro = pro.then(res =&gt; &#123; if (res === undefined) &#123; //表示同意后或者最后一次都是return undefined return //return undefined &#125; else if (res) &#123; console.log(`$&#123;gods[index]&#125;同意了`) return //return undefined &#125; else &#123; console.log(`$&#123;gods[index]&#125;拒绝了`) if (index &lt; gods.length - 1) &#123; return biaobai(`$&#123;gods[index + 1]&#125;`) &#125; &#125; &#125;)&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"ES6 之 Promise（一）","slug":"es6-Promise1","date":"2019-11-05T11:14:50.000Z","updated":"2019-11-12T06:37:12.597Z","comments":true,"path":"2019/11/05/es6-Promise1/","link":"","permalink":"http://yoursite.com/2019/11/05/es6-Promise1/","excerpt":"","text":"前提我们习惯于使用传统的回调或事件处理来解决异步问题，但是随着前端工程越来越复杂，该模式面临以下两个问题： 回调地狱：某个异步操作需要等待之前的异步操作完成，无论用回调还是事件，都会陷入不断的嵌套 1234567891011121314151617181920212223242526272829303132333435//小A心中有三个女神//有一天，小A决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，//直到所有的女神都拒绝，或有一个女神同意为止function biaobai(god, callback) &#123; console.log(`小A向女神【$&#123;god&#125;】发出了表白短信`); setTimeout(() =&gt; &#123; if (Math.random() &lt; 0.1) &#123; callback(true); &#125; else &#123; callback(false); &#125; &#125;, 1000);&#125;biaobai(\"女神1\", function(result) &#123; if (result) &#123; console.log(\"女神1答应了，小A很开心!\") &#125; else &#123; console.log(\"女神1拒绝了，小A表示无压力，然后向女神2表白\"); biaobai(\"女神2\", function(result) &#123; if (result) &#123; console.log(\"女神2答应了，小A很开心!\") &#125; else &#123; console.log(\"女神2十分感动，然后拒绝了小A，小A向女神3表白\"); biaobai(\"女神3\", function(result) &#123; if (result) &#123; console.log(\"女神3答应了，小A很开心!\") &#125; else &#123; console.log(\"小A表示生无可恋!!\"); &#125; &#125;) &#125; &#125;) &#125;&#125;) 异步之间的联系：某个异步操作要等待多个异步操作的结果，对这种联系的处理，会让代码的复杂度剧增 1234567891011121314151617181920212223242526272829303132333435//当所有的女神回复完成后，他要把所有的回复都记录到日志进行分析//因为回复是异步的，所以不能放到函数末尾执行。function biaobai(god, callback) &#123; console.log(`小A向女神【$&#123;god&#125;】发出了表白短信`); setTimeout(() =&gt; &#123; if (Math.random() &lt; 0.05) &#123; callback(true); &#125; else &#123; callback(false); &#125; &#125;, Math.floor(Math.random() * (3000 - 1000) + 1000)); //模拟异步，每个女神回复的时间不同&#125;let agreeGod = null; //同意小A的第一个女神 （只能建立一个全局变量）const results = []; //用于记录回复结果的数组for (let i = 1; i &lt;= 20; i++) &#123; biaobai(`女神$&#123;i&#125;`, result =&gt; &#123; results.push(result); //每次向数组添加一个女神 if (result) &#123; console.log(`女神$&#123;i&#125;同意了`) if (agreeGod) &#123; console.log(`小A回复女神$&#123;i&#125;: 不好意思，刚才朋友用我手机，乱发的`) &#125; else &#123; agreeGod = `女神$&#123;i&#125;`; console.log(`小A终于找到了真爱`); &#125; &#125; else &#123; console.log(`女神$&#123;i&#125;拒绝了`) &#125; if (results.length === 20) &#123; console.log(\"日志记录\", results) //终于得到所有的日志 &#125; &#125;)&#125;//记录日志是一个单独的功能，这样穿插到代码中，会使代码易读性变差，并且日后添加其他模块的时候不好扩展或维护 ES官方参考了大量的异步场景，总结出了一套异步的通用模型，该模型可以覆盖几乎所有的异步场景，甚至是同步场景，也就是Promise。 通用模型 Promise的基本使用123456789101112131415161718192021const pro = new Promise((resolve, reject)=&gt;&#123; // 未决阶段的处理（同步，立即处理） // 通过调用resolve函数将Promise推向已决阶段的resolved状态或者调用reject函数将Promise推向已决阶段的rejected状态 // resolve和reject均可以传递最多一个参数，表示推向状态的数据 // resolve和reject均不可逆，resolve后再reject，reject不会执行&#125;)//第一种写法pro.then(data=&gt;&#123; //这是thenable函数，如果当前的Promise已经是resolved状态，该函数会立即执行 //如果当前是未决阶段，则会加入到作业队列，等待到达resolved状态后执行 //data为传出来的数据&#125;, err=&gt;&#123; //这是catchable函数，如果当前的Promise已经是rejected状态，该函数会立即执行 //如果当前是未决阶段，则会加入到作业队列，等待到达rejected状态后执行&#125;)//第二种写法pro.then(data=&gt;&#123; //同上&#125;).catch(err=&gt;&#123; //同上&#125;) 使用promise后： 12345678910111213141516function biaobai(god) &#123; return new Promise(resolve =&gt; &#123; console.log(`小A向$&#123;god&#125;发出了表白短信`); setTimeout(() =&gt; &#123; if (Math.random() &lt; 0.1) &#123; resolve(true) //不管是同意还是拒绝都是resolve &#125; else &#123; resolve(false); &#125; &#125;, 3000); &#125;)&#125;biaobai(\"女神1\").then(result =&gt; &#123; console.log(result);&#125;) 细节 未决阶段的处理函数是同步的，会立即执行 1234const pro = new Promise((res, rej) =&gt; &#123; console.log('未决阶段') //立即执行 res('data') &#125;) thenable和catchable函数是异步的，就算是立即执行，也会加入到事件队列中等待执行，并且，加入的队列是微队列 1234567const pro = new Promise((res, rej) =&gt; &#123; res(1) &#125;)pro.then(res =&gt; &#123; console.log(res) //异步，在微队列里&#125;)console.log(2) //输出 2 1 pro.then可以只添加thenable函数，pro.catch可以单独添加catchable函数 在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向rejected，并会被catchable捕获 12345678const pro = new Promise((res, rej) =&gt; &#123; throw new Error('ERROR') //可以把状态推向rejected res('data') //不会执行&#125;)pro.catch(err =&gt; &#123; console.log(err) //可以捕获到错误信息&#125;) 一旦状态推向了已决阶段，无法再对状态做任何更改 12345const pro = new Promise((res, rej) =&gt; &#123; res(1) //已经推向已决阶段 res(2)//不会执行 rej(3)//不会执行&#125;) Promise并没有消除回调，只是让回调变得可控 如何处理回调地狱请看下一篇 ES6 之 Promise（二）","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"异步处理 之 事件循环","slug":"异步处理之事件循环","date":"2019-11-04T12:56:58.000Z","updated":"2019-11-12T06:02:12.845Z","comments":true,"path":"2019/11/04/异步处理之事件循环/","link":"","permalink":"http://yoursite.com/2019/11/04/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"JS引擎对事件队列的取出执行方式，以及与宿主环境的配合，称之为事件循环。 宿主环境浏览器宿主环境中包含5个线程： JS引擎：负责执行执行栈的最顶部代码 GUI线程：负责渲染页面 事件监听线程：负责监听各种事件 计时线程：负责计时 网络线程：负责网络通信 JS运行的环境称之为宿主环境。 执行栈 执行栈：call stack，一个数据结构，用于存放各种函数的执行环境(执行上下文)。函数调用之前，创建执行上下文，然后加入到执行栈；函数调用之后，销毁执行上下文。 JS引擎永远执行的是执行栈的最顶部。 异步函数：某些函数不会立即执行，需要等到某个时机到达后才会执行，这样的函数称之为异步函数。比如事件处理函数。异步函数的执行时机，会被宿主环境控制。 事件队列当上面的线程发生了某些事请，如果该线程发现，这件事情有处理程序，它会将该处理程序加入一个叫做事件队列的内存。当JS引擎发现，执行栈中已经没有了任何内容后，会将事件队列中的第一个函数加入到执行栈中执行。 事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种： 宏任务（队列）：macroTask，计时器结束的回调、事件回调、http回调等等绝大部分异步函数进入宏队列 微任务（队列）：MutationObserver，Promise产生的回调进入微队列 MutationObserver用于监听某个DOM对象的变化 当执行栈清空时，JS引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务。 1234567891011121314 console.log(\"a\") setTimeout(function a() &#123; console.log('b') &#125;, 0); for (let i = 0; i &lt; 1000; i++) &#123; console.log(\"c\") &#125; // 输出a 1000个c b//首先创建一个全局上下文，然后创建log上下文，输出a，log上下文销毁。//创建一个settimeout上下文，把settimeout放到宿主环境中的其他线程进行执行，settimeout执行完，销毁上下文//当0秒后监听线程监听到settimeout到时，就会把函数a放入宏队列中//执行循环，创建log上下文，输出c，销毁log上下文，循环1000次。//执行栈里面没有内容，看队列，把队列的函数a放到执行栈中执行。输出b。//全局上下文结束，销毁全局上下文 执行栈 –&gt;(异步函数) 宿主环境 –&gt;(函数) 事件队列 –&gt;(函数) 执行栈 ==&gt;EventLoop","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"ES6 之 块级绑定","slug":"es6-块级绑定","date":"2019-11-03T10:24:40.000Z","updated":"2019-11-11T08:10:00.678Z","comments":true,"path":"2019/11/03/es6-块级绑定/","link":"","permalink":"http://yoursite.com/2019/11/03/es6-%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A/","excerpt":"","text":"用var声明变量的问题 允许重复的变量声明: 导致数据被覆盖 12var a = 1var a = 2 //后者覆盖前者 变量提升: 怪异的数据访问、闭包问题 1234567891011121314151617181920212223242526//怪异的数据访问if (Math.random() &lt; 0.5) &#123; var a = \"abc\"; console.log(a);&#125;else &#123; console.log(a); //没有声明a，但是不会报错 undefined&#125;console.log(a); //没有声明a，但是不会报错 undefined//闭包问题var div = document.getElementById(\"divButtons\")for (var i = 1; i &lt;= 10; i++) &#123; var btn = document.createElement(\"button\"); btn.innerHTML = \"按钮\" + i; div.appendChild(btn); btn.onclick = function () &#123; console.log(i); //输出11 &#125;&#125;// 循环结束后，i：11 // 因为var变量提升，每次var i = i，相当于把全局的i都覆盖了，而点击事件是异步的，点击的时候i全部为你11了 全局变量挂载到全局对象: 全局对象成员污染问题123var console = \"abc\";console.log(console) //var的时候相当于在window上添加属性，所以如果window有这个属性，则会被覆盖。 es6不仅引入let、const关键字用于解决变量声明的问题，同时引入了块级作用域的概念。 块级作用域： 代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域。（if 或 for的花括号） 使用let声明变量 let声明的变量不会挂载到全局对象，解决全局对象被污染问题 12let a = 123;console.log(window.a) //undefined let声明的变量，不允许当前作用域范围内重复声明，解决变量被覆盖问题 1234let a = 123;let a = 456; // ' Identifier 'b' has already been declared' //检查到，当前作用域（全局作用域）已声明了变量a let声明的变量不会变量提升：解决怪异的数据访问、闭包问题123456789101112131415161718192021if (Math.random() &lt; 0.5) &#123; let a = 123; //定义在当前块级作用域 console.log(a) //当前块级作用域中的a&#125;else &#123; //这是另外一个块级作用域，该作用域中找不到a console.log(a) //a is not defined&#125;console.log(a); //a is not defined//闭包let div = document.getElementById(\"divButtons\");for (let i = 1; i &lt;= 10; i++) &#123; //每次let都是创建一个新的块级作用域，里面i不会被覆盖。 let button = document.createElement(\"button\") button.innerHTML = \"按钮\" + i; button.onclick = function () &#123; console.log(i) //使用的是当前作用域中的i &#125; div.appendChild(button)&#125; 底层实现上，let声明的变量实际也会有提升，但是，提升后会将其放入‘暂时性死区’，如果访问的变量位于暂时性死区，则会报错‘Cannot access ‘a’ before initialization’,当代码运行到该变量的声明语句时，会将其从暂时性死区中移除。 在循环中，用let声明的循环变量，会特殊处理，每次进入循环体，都会开启一个新的作用域，并且将循环变量绑定到该作用域。在循环中使用的let声明的循环变量，在循环结束后会销毁。 使用const声明变量和let完全相同，仅在于用const声明的变量，必须在声明时赋值，并且不可以重新赋值。 注意 常量不可变，是指声明常量的内存空间不可变，并不保证内存空间中的地址指向的其他空间不可变。 12345678910const a = &#123; name: '123', age: 18&#125;a.name = 456 //不会报错a = &#123; name: 456, age: 18&#125; //赋值了一个新的地址，会报错 常量的命名 特殊的常量：该常量从字面意义上，一定是不可变的。（圆周率、月地距离），通常该常量的名称全部使用大写，多个单词之间用下划线分割（PI、MOON_DIS） 普通的常量：使用和之前一样的命名即可 在for循环中，循环变量不能使用常量","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"ES6 之 概述","slug":"es6概述","date":"2019-11-02T11:45:39.000Z","updated":"2019-11-14T07:47:19.341Z","comments":true,"path":"2019/11/02/es6概述/","link":"","permalink":"http://yoursite.com/2019/11/02/es6%E6%A6%82%E8%BF%B0/","excerpt":"","text":"ES6概述ECMAScript、JavaScript、NodeJs，它们的区别是什么？ECMAScript：简称ES，是一个语言标准（循环、判断、变量、数组等数据类型） JavaScript：运行在浏览器端的语言，该语言使用ES标准。 ES + web api = JavaScript NodeJs：运行在服务器端的语言，该语言使用ES标准。 ES + node api = NodeJs 无论JavaScript，还是NodeJs，它们都是ES的超集（super set） ECMAScript有哪些关键的版本？ES3.0:1999 ES5.0:2009 ES6.0:2015, 从该版本开始，不再使用数字作为编号，而使用年份 ES7.0:2016 为什么ES6如此重要？ES6解决JS无法开发大型应用的语言层面的问题。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]}]}