{"meta":{"title":"W。的个人博客","subtitle":"只想做一只安静的程序猿","description":"","author":"W。","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-11-11T00:53:54.000Z","updated":"2019-11-11T00:54:12.947Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-11-11T00:54:23.000Z","updated":"2019-11-11T00:54:38.647Z","comments":true,"path":"link/index.html","permalink":"http://yoursite.com/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-11T00:53:14.000Z","updated":"2019-11-11T00:53:41.229Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ES6-Promise","slug":"es6-Promise","date":"2019-11-05T11:14:50.000Z","updated":"2019-11-11T09:28:12.649Z","comments":true,"path":"2019/11/05/es6-Promise/","link":"","permalink":"http://yoursite.com/2019/11/05/es6-Promise/","excerpt":"","text":"前提我们习惯于使用传统的回调或事件处理来解决异步问题，但是随着前端工程越来越复杂，该模式面临以下两个问题： 回调地狱：某个异步操作需要等待之前的异步操作完成，无论用回调还是事件，都会陷入不断的嵌套 12345678910111213141516171819202122232425262728293031323334//小A心中有三个女神//有一天，小A决定向第一个女神表白，如果女神拒绝，则向第二个女神表白，//直到所有的女神都拒绝，或有一个女神同意为止function biaobai(god, callback) &#123; console.log(`小A向女神【$&#123;god&#125;】发出了表白短信`); setTimeout(() =&gt; &#123; if (Math.random() &lt; 0.1) &#123; callback(true); &#125; else &#123; callback(false); &#125; &#125;, 1000);&#125;biaobai(\"女神1\", function(result) &#123; if (result) &#123; console.log(\"女神1答应了，小A很开心!\") &#125; else &#123; console.log(\"女神1拒绝了，小A表示无压力，然后向女神2表白\"); biaobai(\"女神2\", function(result) &#123; if (result) &#123; console.log(\"女神2答应了，小A很开心!\") &#125; else &#123; console.log(\"女神2十分感动，然后拒绝了小A，小A向女神3表白\"); biaobai(\"女神3\", function(result) &#123; if (result) &#123; console.log(\"女神3答应了，小A很开心!\") &#125; else &#123; console.log(\"小A表示生无可恋!!\"); &#125; &#125;) &#125; &#125;) &#125;&#125;) 异步之间的联系：某个异步操作要等待多个异步操作的结果，对这种联系的处理，会让代码的复杂度剧增 12345678910111213141516171819202122232425262728293031323334//当所有的女神回复完成后，他要把所有的回复都记录到日志进行分析//因为回复是异步的，所以不能放到函数末尾执行。function biaobai(god, callback) &#123; console.log(`小A向女神【$&#123;god&#125;】发出了表白短信`); setTimeout(() =&gt; &#123; if (Math.random() &lt; 0.05) &#123; callback(true); &#125; else &#123; callback(false); &#125; &#125;, Math.floor(Math.random() * (3000 - 1000) + 1000)); //模拟异步，每个女神回复的时间不同&#125;let agreeGod = null; //同意小A的第一个女神 （只能建立一个全局变量）const results = []; //用于记录回复结果的数组for (let i = 1; i &lt;= 20; i++) &#123; biaobai(`女神$&#123;i&#125;`, result =&gt; &#123; results.push(result); //每次向数组添加一个女神 if (result) &#123; console.log(`女神$&#123;i&#125;同意了`) if (agreeGod) &#123; console.log(`小A回复女神$&#123;i&#125;: 不好意思，刚才朋友用我手机，乱发的`) &#125; else &#123; agreeGod = `女神$&#123;i&#125;`; console.log(`小A终于找到了真爱`); &#125; &#125; else &#123; console.log(`女神$&#123;i&#125;拒绝了`) &#125; if (results.length === 20) &#123; console.log(\"日志记录\", results) //终于得到所有的日志 &#125; &#125;)&#125;//记录日志是一个单独的功能，这样穿插到代码中，会使代码易读性变差，并且日后添加其他模块的时候不好扩展或维护 ES官方参考了大量的异步场景，总结出了一套异步的通用模型，该模型可以覆盖几乎所有的异步场景，甚至是同步场景，也就是Promise。 通用模型 Promise的基本使用123456789101112131415161718192021const pro = new Promise((resolve, reject)=&gt;&#123; // 未决阶段的处理（同步，立即处理） // 通过调用resolve函数将Promise推向已决阶段的resolved状态或者调用reject函数将Promise推向已决阶段的rejected状态 // resolve和reject均可以传递最多一个参数，表示推向状态的数据 // resolve和reject均不可逆，resolve后再reject，reject不会执行&#125;)//第一种写法pro.then(data=&gt;&#123; //这是thenable函数，如果当前的Promise已经是resolved状态，该函数会立即执行 //如果当前是未决阶段，则会加入到作业队列，等待到达resolved状态后执行 //data为传出来的数据&#125;, err=&gt;&#123; //这是catchable函数，如果当前的Promise已经是rejected状态，该函数会立即执行 //如果当前是未决阶段，则会加入到作业队列，等待到达rejected状态后执行&#125;)//第二种写法pro.then(data=&gt;&#123; //同上&#125;).catch(err=&gt;&#123; //同上&#125;) 细节 未决阶段的处理函数是同步的，会立即执行 thenable和catchable函数是异步的，就算是立即执行，也会加入到事件队列中等待执行，并且，加入的队列是微队列 pro.then可以只添加thenable函数，pro.catch可以单独添加catchable函数 在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向rejected，并会被catchable捕获 1234567const pro = new Promise((res, rej) =&gt; &#123; throw new Error('ERROR') //可以把状态推向rejected res('data') //不会执行&#125;)pro.catch(err =&gt; &#123; console.log(err) //可以捕获到错误信息&#125;) 一旦状态推向了已决阶段，无法再对状态做任何更改 Promise并没有消除回调，只是让回调变得可控","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"异步处理 之 事件循环","slug":"异步处理之事件循环","date":"2019-11-04T12:56:58.000Z","updated":"2019-11-11T08:10:04.712Z","comments":true,"path":"2019/11/04/异步处理之事件循环/","link":"","permalink":"http://yoursite.com/2019/11/04/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"JS引擎对事件队列的取出执行方式，以及与宿主环境的配合，称之为事件循环。 宿主环境浏览器宿主环境中包含5个线程： JS引擎：负责执行执行栈的最顶部代码 GUI线程：负责渲染页面 事件监听线程：负责监听各种事件 计时线程：负责计时 网络线程：负责网络通信 JS运行的环境称之为宿主环境。 执行栈 执行栈：call stack，一个数据结构，用于存放各种函数的执行环境(执行上下文)。函数调用之前，创建执行上下文，然后加入到执行栈；函数调用之后，销毁执行上下文。 JS引擎永远执行的是执行栈的最顶部。 异步函数：某些函数不会立即执行，需要等到某个时机到达后才会执行，这样的函数称之为异步函数。比如事件处理函数。异步函数的执行时机，会被宿主环境控制。 事件队列当上面的线程发生了某些事请，如果该线程发现，这件事情有处理程序，它会将该处理程序加入一个叫做事件队列的内存。当JS引擎发现，执行栈中已经没有了任何内容后，会将事件队列中的第一个函数加入到执行栈中执行。 事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种： 宏任务（队列）：macroTask，计时器结束的回调、事件回调、http回调等等绝大部分异步函数进入宏队列 微任务（队列）：MutationObserver，Promise产生的回调进入微队列 MutationObserver用于监听某个DOM对象的变化 当执行栈清空时，JS引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务。 1234567891011121314 console.log(\"a\") setTimeout(function a() &#123; console.log('b') &#125;, 0); for (let i = 0; i &lt; 1000; i++) &#123; console.log(\"c\") &#125; // 输出a 1000个c b//首先创建一个全局上下文，然后创建log上下文，输出a，log上下文销毁。//创建一个settimeout上下文，把settimeout放到宿主环境中的其他线程进行执行，settimeout执行完，销毁上下文//当0秒后监听线程监听到settimeout到时，就会把函数a放入宏队列中//执行循环，创建log上下文，输出c，销毁log上下文，循环1000次。//执行栈里面没有内容，看队列，把队列的函数a放到执行栈中执行。输出b。//全局上下文结束，销毁全局上下文 执行栈 –&gt;(异步函数) 宿主环境 –&gt;(函数) 事件队列 –&gt;(函数) 执行栈 ==&gt;EventLoop","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"ES6 之 块级绑定","slug":"es6-块级绑定","date":"2019-11-03T10:24:40.000Z","updated":"2019-11-11T08:10:00.678Z","comments":true,"path":"2019/11/03/es6-块级绑定/","link":"","permalink":"http://yoursite.com/2019/11/03/es6-%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A/","excerpt":"","text":"用var声明变量的问题 允许重复的变量声明: 导致数据被覆盖 12var a = 1var a = 2 //后者覆盖前者 变量提升: 怪异的数据访问、闭包问题 1234567891011121314151617181920212223242526//怪异的数据访问if (Math.random() &lt; 0.5) &#123; var a = \"abc\"; console.log(a);&#125;else &#123; console.log(a); //没有声明a，但是不会报错 undefined&#125;console.log(a); //没有声明a，但是不会报错 undefined//闭包问题var div = document.getElementById(\"divButtons\")for (var i = 1; i &lt;= 10; i++) &#123; var btn = document.createElement(\"button\"); btn.innerHTML = \"按钮\" + i; div.appendChild(btn); btn.onclick = function () &#123; console.log(i); //输出11 &#125;&#125;// 循环结束后，i：11 // 因为var变量提升，每次var i = i，相当于把全局的i都覆盖了，而点击事件是异步的，点击的时候i全部为你11了 全局变量挂载到全局对象: 全局对象成员污染问题123var console = \"abc\";console.log(console) //var的时候相当于在window上添加属性，所以如果window有这个属性，则会被覆盖。 es6不仅引入let、const关键字用于解决变量声明的问题，同时引入了块级作用域的概念。 块级作用域： 代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域。（if 或 for的花括号） 使用let声明变量 let声明的变量不会挂载到全局对象，解决全局对象被污染问题 12let a = 123;console.log(window.a) //undefined let声明的变量，不允许当前作用域范围内重复声明，解决变量被覆盖问题 1234let a = 123;let a = 456; // ' Identifier 'b' has already been declared' //检查到，当前作用域（全局作用域）已声明了变量a let声明的变量不会变量提升：解决怪异的数据访问、闭包问题123456789101112131415161718192021if (Math.random() &lt; 0.5) &#123; let a = 123; //定义在当前块级作用域 console.log(a) //当前块级作用域中的a&#125;else &#123; //这是另外一个块级作用域，该作用域中找不到a console.log(a) //a is not defined&#125;console.log(a); //a is not defined//闭包let div = document.getElementById(\"divButtons\");for (let i = 1; i &lt;= 10; i++) &#123; //每次let都是创建一个新的块级作用域，里面i不会被覆盖。 let button = document.createElement(\"button\") button.innerHTML = \"按钮\" + i; button.onclick = function () &#123; console.log(i) //使用的是当前作用域中的i &#125; div.appendChild(button)&#125; 底层实现上，let声明的变量实际也会有提升，但是，提升后会将其放入‘暂时性死区’，如果访问的变量位于暂时性死区，则会报错‘Cannot access ‘a’ before initialization’,当代码运行到该变量的声明语句时，会将其从暂时性死区中移除。 在循环中，用let声明的循环变量，会特殊处理，每次进入循环体，都会开启一个新的作用域，并且将循环变量绑定到该作用域。在循环中使用的let声明的循环变量，在循环结束后会销毁。 使用const声明变量和let完全相同，仅在于用const声明的变量，必须在声明时赋值，并且不可以重新赋值。 注意 常量不可变，是指声明常量的内存空间不可变，并不保证内存空间中的地址指向的其他空间不可变。 12345678910const a = &#123; name: '123', age: 18&#125;a.name = 456 //不会报错a = &#123; name: 456, age: 18&#125; //赋值了一个新的地址，会报错 常量的命名 特殊的常量：该常量从字面意义上，一定是不可变的。（圆周率、月地距离），通常该常量的名称全部使用大写，多个单词之间用下划线分割（PI、MOON_DIS） 普通的常量：使用和之前一样的命名即可 在for循环中，循环变量不能使用常量","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"ES6概述","slug":"es6概述","date":"2019-11-02T11:45:39.000Z","updated":"2019-11-11T08:09:58.138Z","comments":true,"path":"2019/11/02/es6概述/","link":"","permalink":"http://yoursite.com/2019/11/02/es6%E6%A6%82%E8%BF%B0/","excerpt":"","text":"ES6概述ECMAScript、JavaScript、NodeJs，它们的区别是什么？ECMAScript：简称ES，是一个语言标准（循环、判断、变量、数组等数据类型） JavaScript：运行在浏览器端的语言，该语言使用ES标准。 ES + web api = JavaScript NodeJs：运行在服务器端的语言，该语言使用ES标准。 ES + node api = NodeJs 无论JavaScript，还是NodeJs，它们都是ES的超集（super set） ECMAScript有哪些关键的版本？ES3.0： 1999 ES5.0: 2009 ES6.0: 2015, 从该版本开始，不再使用数字作为编号，而使用年份 ES7.0: 2016 为什么ES6如此重要？ES6解决JS无法开发大型应用的语言层面的问题。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]}]}